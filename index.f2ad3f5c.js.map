{"mappings":"IOwRI,ED/QA,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,W,I,E,A,G,E,G,E,E,O,C,U,I,E,A,G,E,GLPJ,IAgBA,EACA,EAjBI,EAAU,IAAI,IAgBlB,EAfA,SAAkB,CAAO,CAAE,CAAQ,EACjC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAG,EAAG,GAAK,EAC5C,EAAQ,GAAG,CAAC,CAAQ,CAAC,EAAE,CAAE,CACvB,QAAS,EACT,KAAM,CAAQ,CAAC,EAAI,EAAE,AACvB,EAEJ,EASA,EARA,SAAiB,CAAE,EACjB,IAAI,EAAW,EAAQ,GAAG,CAAC,GAC3B,GAAI,AAAY,MAAZ,EACF,MAAM,AAAI,MAAM,oCAAsC,GAExD,OAAO,IAAI,IAAI,EAAS,IAAI,CAAE,EAAS,OAAO,EAAE,QAAQ,EAC1D,C,G,E,Q,S,C,C,C,E,I,E,E,QChBA,CAAA,EAAA,OAAA,CAAiB,QAAQ,GAAG,CAAC,CAAC,EAAK,SAAU,EAAK,SAAS,EAAE,IAAI,CAAC,IAAM,EAAc,S,G,E,Q,S,C,C,C,ECKtF,EAAA,OAAA,CAJA,SAAc,CAAE,EAEd,OAAO,MAAA,CAAmB,AAAA,EAAA,SAAA,OAAA,CAAsC,GAClE,C,G,E,Q,S,C,C,C,E,I,E,E,QCJA,CAAA,EAAA,OAAA,CAAkB,EAAK,SAAU,IAAI,CAAC,IAAM,EAAc,S,GCD1D,AAAA,EAAA,SAAA,QAAA,CAA8C,IAAA,IAAoB,GAAA,YAAA,GAAA,EAAI,QAAQ,GAAG,KAAK,KAAK,CAAC,yJEA5F,IAAI,EAAK,IAAI,KAAK,QAAQ,CAAC,EAAG,CAAE,QAAS,CAAE,GAAG,OAAO,CACrD,SAAS,EAAQ,C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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-abeac20f30367250.js","node_modules/@parcel/runtime-js/lib/helpers/browser/esm-js-loader.js","node_modules/@parcel/runtime-js/lib/runtime-77046cffcee4d29d.js","node_modules/@parcel/runtime-js/lib/runtime-7100fded09e52137.js","src/script.js","node_modules/@gradio/client/dist/index.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequiref722\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequiref722\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"27Lyk\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", () => $18c11f3350a906ea$export$6503ec6e8aabbaf, (v) => $18c11f3350a906ea$export$6503ec6e8aabbaf = v);\n$parcel$export(module.exports, \"resolve\", () => $18c11f3350a906ea$export$f7ad0328861e2f03, (v) => $18c11f3350a906ea$export$f7ad0328861e2f03 = v);\nvar $18c11f3350a906ea$export$6503ec6e8aabbaf;\nvar $18c11f3350a906ea$export$f7ad0328861e2f03;\n\"use strict\";\nvar $18c11f3350a906ea$var$mapping = new Map();\nfunction $18c11f3350a906ea$var$register(baseUrl, manifest) {\n    for(var i = 0; i < manifest.length - 1; i += 2)$18c11f3350a906ea$var$mapping.set(manifest[i], {\n        baseUrl: baseUrl,\n        path: manifest[i + 1]\n    });\n}\nfunction $18c11f3350a906ea$var$resolve(id) {\n    var resolved = $18c11f3350a906ea$var$mapping.get(id);\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return new URL(resolved.path, resolved.baseUrl).toString();\n}\n$18c11f3350a906ea$export$6503ec6e8aabbaf = $18c11f3350a906ea$var$register;\n$18c11f3350a906ea$export$f7ad0328861e2f03 = $18c11f3350a906ea$var$resolve;\n\n});\n\nparcelRegister(\"4xckJ\", function(module, exports) {\n\nvar $Gr8vk = parcelRequire(\"Gr8vk\");\nmodule.exports = Promise.all([\n    $Gr8vk(\"gan9g\"),\n    $Gr8vk(\"b9Ask\")\n]).then(()=>parcelRequire(\"42ZAn\"));\n\n});\nparcelRegister(\"Gr8vk\", function(module, exports) {\n\"use strict\";\n\nfunction $07f8f9093a769793$var$load(id) {\n    // eslint-disable-next-line no-undef\n    return import((parcelRequire(\"27Lyk\")).resolve(id));\n}\nmodule.exports = $07f8f9093a769793$var$load;\n\n});\n\n\nparcelRegister(\"2XQ4x\", function(module, exports) {\n\nvar $Gr8vk = parcelRequire(\"Gr8vk\");\nmodule.exports = $Gr8vk(\"gan9g\").then(()=>parcelRequire(\"6ZWSX\"));\n\n});\n\nvar $deb4352c076a898a$exports = {};\n\n(parcelRequire(\"27Lyk\")).register(new URL(\"\", import.meta.url).toString(), JSON.parse('[\"kb9mm\",\"index.f2ad3f5c.js\",\"b9Ask\",\"wrapper-6f348d45.b164e76d.js\",\"gan9g\",\"buffer.d9bd03a9.js\"]'));\n\nvar $9b72dfb568173b1a$var$fn = new Intl.Collator(0, {\n    numeric: 1\n}).compare;\nfunction $9b72dfb568173b1a$var$semiver(a, b, bool) {\n    a = a.split(\".\");\n    b = b.split(\".\");\n    return $9b72dfb568173b1a$var$fn(a[0], b[0]) || $9b72dfb568173b1a$var$fn(a[1], b[1]) || (b[2] = b.slice(2).join(\".\"), bool = /[.-]/.test(a[2] = a.slice(2).join(\".\")), bool == /[.-]/.test(b[2]) ? $9b72dfb568173b1a$var$fn(a[2], b[2]) : bool ? -1 : 1);\n}\nfunction $9b72dfb568173b1a$var$resolve_root(base_url, root_path, prioritize_base) {\n    if (root_path.startsWith(\"http://\") || root_path.startsWith(\"https://\")) return prioritize_base ? base_url : root_path;\n    return base_url + root_path;\n}\nfunction $9b72dfb568173b1a$var$determine_protocol(endpoint) {\n    if (endpoint.startsWith(\"http\")) {\n        const { protocol: protocol, host: host } = new URL(endpoint);\n        if (host.endsWith(\"hf.space\")) return {\n            ws_protocol: \"wss\",\n            host: host,\n            http_protocol: protocol\n        };\n        return {\n            ws_protocol: protocol === \"https:\" ? \"wss\" : \"ws\",\n            http_protocol: protocol,\n            host: host\n        };\n    } else if (endpoint.startsWith(\"file:\")) return {\n        ws_protocol: \"ws\",\n        http_protocol: \"http:\",\n        host: \"lite.local\"\n    };\n    return {\n        ws_protocol: \"wss\",\n        http_protocol: \"https:\",\n        host: endpoint\n    };\n}\nconst $9b72dfb568173b1a$var$RE_SPACE_NAME = /^[^\\/]*\\/[^\\/]*$/;\nconst $9b72dfb568173b1a$var$RE_SPACE_DOMAIN = /.*hf\\.space\\/{0,1}$/;\nasync function $9b72dfb568173b1a$var$process_endpoint(app_reference, token) {\n    const headers = {};\n    if (token) headers.Authorization = `Bearer ${token}`;\n    const _app_reference = app_reference.trim();\n    if ($9b72dfb568173b1a$var$RE_SPACE_NAME.test(_app_reference)) try {\n        const res = await fetch(`https://huggingface.co/api/spaces/${_app_reference}/host`, {\n            headers: headers\n        });\n        if (res.status !== 200) throw new Error(\"Space metadata could not be loaded.\");\n        const _host = (await res.json()).host;\n        return {\n            space_id: app_reference,\n            ...$9b72dfb568173b1a$var$determine_protocol(_host)\n        };\n    } catch (e) {\n        throw new Error(\"Space metadata could not be loaded.\" + e.message);\n    }\n    if ($9b72dfb568173b1a$var$RE_SPACE_DOMAIN.test(_app_reference)) {\n        const { ws_protocol: ws_protocol, http_protocol: http_protocol, host: host } = $9b72dfb568173b1a$var$determine_protocol(_app_reference);\n        return {\n            space_id: host.replace(\".hf.space\", \"\"),\n            ws_protocol: ws_protocol,\n            http_protocol: http_protocol,\n            host: host\n        };\n    }\n    return {\n        space_id: false,\n        ...$9b72dfb568173b1a$var$determine_protocol(_app_reference)\n    };\n}\nfunction $9b72dfb568173b1a$var$map_names_to_ids(fns) {\n    let apis = {};\n    fns.forEach(({ api_name: api_name }, i)=>{\n        if (api_name) apis[api_name] = i;\n    });\n    return apis;\n}\nconst $9b72dfb568173b1a$var$RE_DISABLED_DISCUSSION = /^(?=[^]*\\b[dD]iscussions{0,1}\\b)(?=[^]*\\b[dD]isabled\\b)[^]*$/;\nasync function $9b72dfb568173b1a$var$discussions_enabled(space_id) {\n    try {\n        const r = await fetch(`https://huggingface.co/api/spaces/${space_id}/discussions`, {\n            method: \"HEAD\"\n        });\n        const error = r.headers.get(\"x-error-message\");\n        if (error && $9b72dfb568173b1a$var$RE_DISABLED_DISCUSSION.test(error)) return false;\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nasync function $9b72dfb568173b1a$var$get_space_hardware(space_id, token) {\n    const headers = {};\n    if (token) headers.Authorization = `Bearer ${token}`;\n    try {\n        const res = await fetch(`https://huggingface.co/api/spaces/${space_id}/runtime`, {\n            headers: headers\n        });\n        if (res.status !== 200) throw new Error(\"Space hardware could not be obtained.\");\n        const { hardware: hardware } = await res.json();\n        return hardware;\n    } catch (e) {\n        throw new Error(e.message);\n    }\n}\nasync function $9b72dfb568173b1a$var$set_space_hardware(space_id, new_hardware, token) {\n    const headers = {};\n    if (token) headers.Authorization = `Bearer ${token}`;\n    try {\n        const res = await fetch(`https://huggingface.co/api/spaces/${space_id}/hardware`, {\n            headers: headers,\n            body: JSON.stringify(new_hardware)\n        });\n        if (res.status !== 200) throw new Error(\"Space hardware could not be set. Please ensure the space hardware provided is valid and that a Hugging Face token is passed in.\");\n        const { hardware: hardware } = await res.json();\n        return hardware;\n    } catch (e) {\n        throw new Error(e.message);\n    }\n}\nasync function $9b72dfb568173b1a$var$set_space_timeout(space_id, timeout, token) {\n    const headers = {};\n    if (token) headers.Authorization = `Bearer ${token}`;\n    try {\n        const res = await fetch(`https://huggingface.co/api/spaces/${space_id}/hardware`, {\n            headers: headers,\n            body: JSON.stringify({\n                seconds: timeout\n            })\n        });\n        if (res.status !== 200) throw new Error(\"Space hardware could not be set. Please ensure the space hardware provided is valid and that a Hugging Face token is passed in.\");\n        const { hardware: hardware } = await res.json();\n        return hardware;\n    } catch (e) {\n        throw new Error(e.message);\n    }\n}\nconst $9b72dfb568173b1a$var$hardware_types = [\n    \"cpu-basic\",\n    \"cpu-upgrade\",\n    \"t4-small\",\n    \"t4-medium\",\n    \"a10g-small\",\n    \"a10g-large\",\n    \"a100-large\"\n];\nfunction $9b72dfb568173b1a$var$apply_edit(target, path, action, value) {\n    if (path.length === 0) {\n        if (action === \"replace\") return value;\n        else if (action === \"append\") return target + value;\n        throw new Error(`Unsupported action: ${action}`);\n    }\n    let current = target;\n    for(let i = 0; i < path.length - 1; i++)current = current[path[i]];\n    const last_path = path[path.length - 1];\n    switch(action){\n        case \"replace\":\n            current[last_path] = value;\n            break;\n        case \"append\":\n            current[last_path] += value;\n            break;\n        case \"add\":\n            if (Array.isArray(current)) current.splice(Number(last_path), 0, value);\n            else current[last_path] = value;\n            break;\n        case \"delete\":\n            if (Array.isArray(current)) current.splice(Number(last_path), 1);\n            else delete current[last_path];\n            break;\n        default:\n            throw new Error(`Unknown action: ${action}`);\n    }\n    return target;\n}\nfunction $9b72dfb568173b1a$var$apply_diff(obj, diff) {\n    diff.forEach(([action, path, value])=>{\n        obj = $9b72dfb568173b1a$var$apply_edit(obj, path, action, value);\n    });\n    return obj;\n}\nasync function $9b72dfb568173b1a$export$a3c8e1472dc2ed84(file_data, root, upload_id, upload_fn = $9b72dfb568173b1a$export$db33103a2a87725a) {\n    let files = (Array.isArray(file_data) ? file_data : [\n        file_data\n    ]).map((file_data2)=>file_data2.blob);\n    return await Promise.all(await upload_fn(root, files, void 0, upload_id).then(async (response)=>{\n        if (response.error) throw new Error(response.error);\n        else {\n            if (response.files) return response.files.map((f, i)=>{\n                const file = new $9b72dfb568173b1a$export$aa5a39f77f24e0c0({\n                    ...file_data[i],\n                    path: f,\n                    url: root + \"/file=\" + f\n                });\n                return file;\n            });\n            return [];\n        }\n    }));\n}\nasync function $9b72dfb568173b1a$export$251e2fc1af5d10a3(files, is_stream) {\n    return files.map((f, i)=>new $9b72dfb568173b1a$export$aa5a39f77f24e0c0({\n            path: f.name,\n            orig_name: f.name,\n            blob: f,\n            size: f.size,\n            mime_type: f.type,\n            is_stream: is_stream\n        }));\n}\nclass $9b72dfb568173b1a$export$aa5a39f77f24e0c0 {\n    constructor({ path: path, url: url, orig_name: orig_name, size: size, blob: blob, is_stream: is_stream, mime_type: mime_type, alt_text: alt_text }){\n        this.meta = {\n            _type: \"gradio.FileData\"\n        };\n        this.path = path;\n        this.url = url;\n        this.orig_name = orig_name;\n        this.size = size;\n        this.blob = url ? void 0 : blob;\n        this.is_stream = is_stream;\n        this.mime_type = mime_type;\n        this.alt_text = alt_text;\n    }\n}\nconst $9b72dfb568173b1a$var$QUEUE_FULL_MSG = \"This application is too busy. Keep trying!\";\nconst $9b72dfb568173b1a$var$BROKEN_CONNECTION_MSG = \"Connection errored out.\";\nlet $9b72dfb568173b1a$var$NodeBlob;\nasync function $9b72dfb568173b1a$export$ecd5e8ace626722c(app_reference, options) {\n    const { hf_token: hf_token, private: _private, hardware: hardware, timeout: timeout } = options;\n    if (hardware && !$9b72dfb568173b1a$var$hardware_types.includes(hardware)) throw new Error(`Invalid hardware type provided. Valid types are: ${$9b72dfb568173b1a$var$hardware_types.map((v)=>`\"${v}\"`).join(\",\")}.`);\n    const headers = {\n        Authorization: `Bearer ${hf_token}`\n    };\n    const user = (await (await fetch(`https://huggingface.co/api/whoami-v2`, {\n        headers: headers\n    })).json()).name;\n    const space_name = app_reference.split(\"/\")[1];\n    const body = {\n        repository: `${user}/${space_name}`\n    };\n    if (_private) body.private = true;\n    try {\n        const response = await fetch(`https://huggingface.co/api/spaces/${app_reference}/duplicate`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            body: JSON.stringify(body)\n        });\n        if (response.status === 409) return $9b72dfb568173b1a$export$388e0302ca0d9a41(`${user}/${space_name}`, options);\n        const duplicated_space = await response.json();\n        let original_hardware;\n        if (!hardware) original_hardware = await $9b72dfb568173b1a$var$get_space_hardware(app_reference, hf_token);\n        const requested_hardware = hardware || original_hardware || \"cpu-basic\";\n        await $9b72dfb568173b1a$var$set_space_hardware(`${user}/${space_name}`, requested_hardware, hf_token);\n        await $9b72dfb568173b1a$var$set_space_timeout(`${user}/${space_name}`, timeout || 300, hf_token);\n        return $9b72dfb568173b1a$export$388e0302ca0d9a41(duplicated_space.url, options);\n    } catch (e) {\n        throw new Error(e);\n    }\n}\n\n\nfunction $9b72dfb568173b1a$export$e70d99f56c8376bd(fetch_implementation, EventSource_factory) {\n    return {\n        post_data: post_data2,\n        upload_files: upload_files2,\n        client: client2,\n        handle_blob: handle_blob2\n    };\n    async function post_data2(url, body, token) {\n        const headers = {\n            \"Content-Type\": \"application/json\"\n        };\n        if (token) headers.Authorization = `Bearer ${token}`;\n        try {\n            var response = await fetch_implementation(url, {\n                method: \"POST\",\n                body: JSON.stringify(body),\n                headers: headers\n            });\n        } catch (e) {\n            return [\n                {\n                    error: $9b72dfb568173b1a$var$BROKEN_CONNECTION_MSG\n                },\n                500\n            ];\n        }\n        let output;\n        let status;\n        try {\n            output = await response.json();\n            status = response.status;\n        } catch (e) {\n            output = {\n                error: `Could not parse server response: ${e}`\n            };\n            status = 500;\n        }\n        return [\n            output,\n            status\n        ];\n    }\n    async function upload_files2(root, files, token, upload_id) {\n        const headers = {};\n        if (token) headers.Authorization = `Bearer ${token}`;\n        const chunkSize = 1e3;\n        const uploadResponses = [];\n        for(let i = 0; i < files.length; i += chunkSize){\n            const chunk = files.slice(i, i + chunkSize);\n            const formData = new FormData();\n            chunk.forEach((file)=>{\n                formData.append(\"files\", file);\n            });\n            try {\n                const upload_url = upload_id ? `${root}/upload?upload_id=${upload_id}` : `${root}/upload`;\n                var response = await fetch_implementation(upload_url, {\n                    method: \"POST\",\n                    body: formData,\n                    headers: headers\n                });\n            } catch (e) {\n                return {\n                    error: $9b72dfb568173b1a$var$BROKEN_CONNECTION_MSG\n                };\n            }\n            const output = await response.json();\n            uploadResponses.push(...output);\n        }\n        return {\n            files: uploadResponses\n        };\n    }\n    async function client2(app_reference, options = {}) {\n        return new Promise(async (res)=>{\n            const { status_callback: status_callback, hf_token: hf_token } = options;\n            const return_obj = {\n                predict: predict,\n                submit: submit,\n                view_api: view_api,\n                component_server: component_server\n            };\n            if ((typeof window === \"undefined\" || !(\"WebSocket\" in window)) && !$parcel$global.Websocket) {\n                const ws = await (parcelRequire(\"4xckJ\"));\n                $9b72dfb568173b1a$var$NodeBlob = (await (parcelRequire(\"2XQ4x\"))).Blob;\n                $parcel$global.WebSocket = ws.WebSocket;\n            }\n            const { ws_protocol: ws_protocol, http_protocol: http_protocol, host: host, space_id: space_id } = await $9b72dfb568173b1a$var$process_endpoint(app_reference, hf_token);\n            const session_hash = Math.random().toString(36).substring(2);\n            const last_status = {};\n            let stream_open = false;\n            let pending_stream_messages = {};\n            let pending_diff_streams = {};\n            let event_stream = null;\n            const event_callbacks = {};\n            const unclosed_events = /* @__PURE__ */ new Set();\n            let config;\n            let api_map = {};\n            let jwt = false;\n            if (hf_token && space_id) jwt = await $9b72dfb568173b1a$var$get_jwt(space_id, hf_token);\n            async function config_success(_config) {\n                config = _config;\n                if (window.location.protocol === \"https:\") config.root = config.root.replace(\"http://\", \"https://\");\n                api_map = $9b72dfb568173b1a$var$map_names_to_ids((_config == null ? void 0 : _config.dependencies) || []);\n                if (config.auth_required) return {\n                    config: config,\n                    ...return_obj\n                };\n                try {\n                    api = await view_api(config);\n                } catch (e) {\n                    console.error(`Could not get api details: ${e.message}`);\n                }\n                return {\n                    config: config,\n                    ...return_obj\n                };\n            }\n            let api;\n            async function handle_space_sucess(status) {\n                if (status_callback) status_callback(status);\n                if (status.status === \"running\") try {\n                    config = await $9b72dfb568173b1a$var$resolve_config(fetch_implementation, `${http_protocol}//${host}`, hf_token);\n                    const _config = await config_success(config);\n                    res(_config);\n                } catch (e) {\n                    console.error(e);\n                    if (status_callback) status_callback({\n                        status: \"error\",\n                        message: \"Could not load this space.\",\n                        load_status: \"error\",\n                        detail: \"NOT_FOUND\"\n                    });\n                }\n            }\n            try {\n                config = await $9b72dfb568173b1a$var$resolve_config(fetch_implementation, `${http_protocol}//${host}`, hf_token);\n                const _config = await config_success(config);\n                res(_config);\n            } catch (e) {\n                console.error(e);\n                if (space_id) $9b72dfb568173b1a$var$check_space_status(space_id, $9b72dfb568173b1a$var$RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\", handle_space_sucess);\n                else if (status_callback) status_callback({\n                    status: \"error\",\n                    message: \"Could not load this space.\",\n                    load_status: \"error\",\n                    detail: \"NOT_FOUND\"\n                });\n            }\n            function predict(endpoint, data, event_data) {\n                let data_returned = false;\n                let status_complete = false;\n                let dependency;\n                if (typeof endpoint === \"number\") dependency = config.dependencies[endpoint];\n                else {\n                    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n                    dependency = config.dependencies[api_map[trimmed_endpoint]];\n                }\n                if (dependency.types.continuous) throw new Error(\"Cannot call predict on this function as it may run forever. Use submit instead\");\n                return new Promise((res2, rej)=>{\n                    const app = submit(endpoint, data, event_data);\n                    let result;\n                    app.on(\"data\", (d)=>{\n                        if (status_complete) {\n                            app.destroy();\n                            res2(d);\n                        }\n                        data_returned = true;\n                        result = d;\n                    }).on(\"status\", (status)=>{\n                        if (status.stage === \"error\") rej(status);\n                        if (status.stage === \"complete\") {\n                            status_complete = true;\n                            if (data_returned) {\n                                app.destroy();\n                                res2(result);\n                            }\n                        }\n                    });\n                });\n            }\n            function submit(endpoint, data, event_data, trigger_id = null) {\n                let fn_index;\n                let api_info;\n                if (typeof endpoint === \"number\") {\n                    fn_index = endpoint;\n                    api_info = api.unnamed_endpoints[fn_index];\n                } else {\n                    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n                    fn_index = api_map[trimmed_endpoint];\n                    api_info = api.named_endpoints[endpoint.trim()];\n                }\n                if (typeof fn_index !== \"number\") throw new Error(\"There is no endpoint matching that name of fn_index matching that number.\");\n                let websocket;\n                let eventSource;\n                let protocol = config.protocol ?? \"ws\";\n                const _endpoint = typeof endpoint === \"number\" ? \"/predict\" : endpoint;\n                let payload;\n                let event_id = null;\n                let complete = false;\n                const listener_map = {};\n                let url_params = \"\";\n                if (typeof window !== \"undefined\") url_params = new URLSearchParams(window.location.search).toString();\n                handle_blob2(`${config.root}`, data, api_info, hf_token).then((_payload)=>{\n                    payload = {\n                        data: _payload || [],\n                        event_data: event_data,\n                        fn_index: fn_index,\n                        trigger_id: trigger_id\n                    };\n                    if ($9b72dfb568173b1a$var$skip_queue(fn_index, config)) {\n                        fire_event({\n                            type: \"status\",\n                            endpoint: _endpoint,\n                            stage: \"pending\",\n                            queue: false,\n                            fn_index: fn_index,\n                            time: /* @__PURE__ */ new Date()\n                        });\n                        post_data2(`${config.root}/run${_endpoint.startsWith(\"/\") ? _endpoint : `/${_endpoint}`}${url_params ? \"?\" + url_params : \"\"}`, {\n                            ...payload,\n                            session_hash: session_hash\n                        }, hf_token).then(([output, status_code])=>{\n                            const data2 = output.data;\n                            if (status_code == 200) {\n                                fire_event({\n                                    type: \"data\",\n                                    endpoint: _endpoint,\n                                    fn_index: fn_index,\n                                    data: data2,\n                                    time: /* @__PURE__ */ new Date()\n                                });\n                                fire_event({\n                                    type: \"status\",\n                                    endpoint: _endpoint,\n                                    fn_index: fn_index,\n                                    stage: \"complete\",\n                                    eta: output.average_duration,\n                                    queue: false,\n                                    time: /* @__PURE__ */ new Date()\n                                });\n                            } else fire_event({\n                                type: \"status\",\n                                stage: \"error\",\n                                endpoint: _endpoint,\n                                fn_index: fn_index,\n                                message: output.error,\n                                queue: false,\n                                time: /* @__PURE__ */ new Date()\n                            });\n                        }).catch((e)=>{\n                            fire_event({\n                                type: \"status\",\n                                stage: \"error\",\n                                message: e.message,\n                                endpoint: _endpoint,\n                                fn_index: fn_index,\n                                queue: false,\n                                time: /* @__PURE__ */ new Date()\n                            });\n                        });\n                    } else if (protocol == \"ws\") {\n                        fire_event({\n                            type: \"status\",\n                            stage: \"pending\",\n                            queue: true,\n                            endpoint: _endpoint,\n                            fn_index: fn_index,\n                            time: /* @__PURE__ */ new Date()\n                        });\n                        let url = new URL(`${ws_protocol}://${$9b72dfb568173b1a$var$resolve_root(host, config.path, true)}\n\t\t\t\t\t\t\t/queue/join${url_params ? \"?\" + url_params : \"\"}`);\n                        if (jwt) url.searchParams.set(\"__sign\", jwt);\n                        websocket = new WebSocket(url);\n                        websocket.onclose = (evt)=>{\n                            if (!evt.wasClean) fire_event({\n                                type: \"status\",\n                                stage: \"error\",\n                                broken: true,\n                                message: $9b72dfb568173b1a$var$BROKEN_CONNECTION_MSG,\n                                queue: true,\n                                endpoint: _endpoint,\n                                fn_index: fn_index,\n                                time: /* @__PURE__ */ new Date()\n                            });\n                        };\n                        websocket.onmessage = function(event) {\n                            const _data = JSON.parse(event.data);\n                            const { type: type, status: status, data: data2 } = $9b72dfb568173b1a$var$handle_message(_data, last_status[fn_index]);\n                            if (type === \"update\" && status && !complete) {\n                                fire_event({\n                                    type: \"status\",\n                                    endpoint: _endpoint,\n                                    fn_index: fn_index,\n                                    time: /* @__PURE__ */ new Date(),\n                                    ...status\n                                });\n                                if (status.stage === \"error\") websocket.close();\n                            } else if (type === \"hash\") {\n                                websocket.send(JSON.stringify({\n                                    fn_index: fn_index,\n                                    session_hash: session_hash\n                                }));\n                                return;\n                            } else if (type === \"data\") websocket.send(JSON.stringify({\n                                ...payload,\n                                session_hash: session_hash\n                            }));\n                            else if (type === \"complete\") complete = status;\n                            else if (type === \"log\") fire_event({\n                                type: \"log\",\n                                log: data2.log,\n                                level: data2.level,\n                                endpoint: _endpoint,\n                                fn_index: fn_index\n                            });\n                            else if (type === \"generating\") fire_event({\n                                type: \"status\",\n                                time: /* @__PURE__ */ new Date(),\n                                ...status,\n                                stage: status == null ? void 0 : status.stage,\n                                queue: true,\n                                endpoint: _endpoint,\n                                fn_index: fn_index\n                            });\n                            if (data2) {\n                                fire_event({\n                                    type: \"data\",\n                                    time: /* @__PURE__ */ new Date(),\n                                    data: data2.data,\n                                    endpoint: _endpoint,\n                                    fn_index: fn_index\n                                });\n                                if (complete) {\n                                    fire_event({\n                                        type: \"status\",\n                                        time: /* @__PURE__ */ new Date(),\n                                        ...complete,\n                                        stage: status == null ? void 0 : status.stage,\n                                        queue: true,\n                                        endpoint: _endpoint,\n                                        fn_index: fn_index\n                                    });\n                                    websocket.close();\n                                }\n                            }\n                        };\n                        if ($9b72dfb568173b1a$var$semiver(config.version || \"2.0.0\", \"3.6\") < 0) addEventListener(\"open\", ()=>websocket.send(JSON.stringify({\n                                hash: session_hash\n                            })));\n                    } else if (protocol == \"sse\") {\n                        fire_event({\n                            type: \"status\",\n                            stage: \"pending\",\n                            queue: true,\n                            endpoint: _endpoint,\n                            fn_index: fn_index,\n                            time: /* @__PURE__ */ new Date()\n                        });\n                        var params = new URLSearchParams({\n                            fn_index: fn_index.toString(),\n                            session_hash: session_hash\n                        }).toString();\n                        let url = new URL(`${config.root}/queue/join?${url_params ? url_params + \"&\" : \"\"}${params}`);\n                        eventSource = EventSource_factory(url);\n                        eventSource.onmessage = async function(event) {\n                            const _data = JSON.parse(event.data);\n                            const { type: type, status: status, data: data2 } = $9b72dfb568173b1a$var$handle_message(_data, last_status[fn_index]);\n                            if (type === \"update\" && status && !complete) {\n                                fire_event({\n                                    type: \"status\",\n                                    endpoint: _endpoint,\n                                    fn_index: fn_index,\n                                    time: /* @__PURE__ */ new Date(),\n                                    ...status\n                                });\n                                if (status.stage === \"error\") eventSource.close();\n                            } else if (type === \"data\") {\n                                event_id = _data.event_id;\n                                let [_, status2] = await post_data2(`${config.root}/queue/data`, {\n                                    ...payload,\n                                    session_hash: session_hash,\n                                    event_id: event_id\n                                }, hf_token);\n                                if (status2 !== 200) {\n                                    fire_event({\n                                        type: \"status\",\n                                        stage: \"error\",\n                                        message: $9b72dfb568173b1a$var$BROKEN_CONNECTION_MSG,\n                                        queue: true,\n                                        endpoint: _endpoint,\n                                        fn_index: fn_index,\n                                        time: /* @__PURE__ */ new Date()\n                                    });\n                                    eventSource.close();\n                                }\n                            } else if (type === \"complete\") complete = status;\n                            else if (type === \"log\") fire_event({\n                                type: \"log\",\n                                log: data2.log,\n                                level: data2.level,\n                                endpoint: _endpoint,\n                                fn_index: fn_index\n                            });\n                            else if (type === \"generating\") fire_event({\n                                type: \"status\",\n                                time: /* @__PURE__ */ new Date(),\n                                ...status,\n                                stage: status == null ? void 0 : status.stage,\n                                queue: true,\n                                endpoint: _endpoint,\n                                fn_index: fn_index\n                            });\n                            if (data2) {\n                                fire_event({\n                                    type: \"data\",\n                                    time: /* @__PURE__ */ new Date(),\n                                    data: data2.data,\n                                    endpoint: _endpoint,\n                                    fn_index: fn_index\n                                });\n                                if (complete) {\n                                    fire_event({\n                                        type: \"status\",\n                                        time: /* @__PURE__ */ new Date(),\n                                        ...complete,\n                                        stage: status == null ? void 0 : status.stage,\n                                        queue: true,\n                                        endpoint: _endpoint,\n                                        fn_index: fn_index\n                                    });\n                                    eventSource.close();\n                                }\n                            }\n                        };\n                    } else if (protocol == \"sse_v1\" || protocol == \"sse_v2\" || protocol == \"sse_v2.1\") {\n                        fire_event({\n                            type: \"status\",\n                            stage: \"pending\",\n                            queue: true,\n                            endpoint: _endpoint,\n                            fn_index: fn_index,\n                            time: /* @__PURE__ */ new Date()\n                        });\n                        post_data2(`${config.root}/queue/join?${url_params}`, {\n                            ...payload,\n                            session_hash: session_hash\n                        }, hf_token).then(([response, status])=>{\n                            if (status === 503) fire_event({\n                                type: \"status\",\n                                stage: \"error\",\n                                message: $9b72dfb568173b1a$var$QUEUE_FULL_MSG,\n                                queue: true,\n                                endpoint: _endpoint,\n                                fn_index: fn_index,\n                                time: /* @__PURE__ */ new Date()\n                            });\n                            else if (status !== 200) fire_event({\n                                type: \"status\",\n                                stage: \"error\",\n                                message: $9b72dfb568173b1a$var$BROKEN_CONNECTION_MSG,\n                                queue: true,\n                                endpoint: _endpoint,\n                                fn_index: fn_index,\n                                time: /* @__PURE__ */ new Date()\n                            });\n                            else {\n                                event_id = response.event_id;\n                                let callback = async function(_data) {\n                                    try {\n                                        const { type: type, status: status2, data: data2 } = $9b72dfb568173b1a$var$handle_message(_data, last_status[fn_index]);\n                                        if (type == \"heartbeat\") return;\n                                        if (type === \"update\" && status2 && !complete) fire_event({\n                                            type: \"status\",\n                                            endpoint: _endpoint,\n                                            fn_index: fn_index,\n                                            time: /* @__PURE__ */ new Date(),\n                                            ...status2\n                                        });\n                                        else if (type === \"complete\") complete = status2;\n                                        else if (type == \"unexpected_error\") {\n                                            console.error(\"Unexpected error\", status2 == null ? void 0 : status2.message);\n                                            fire_event({\n                                                type: \"status\",\n                                                stage: \"error\",\n                                                message: (status2 == null ? void 0 : status2.message) || \"An Unexpected Error Occurred!\",\n                                                queue: true,\n                                                endpoint: _endpoint,\n                                                fn_index: fn_index,\n                                                time: /* @__PURE__ */ new Date()\n                                            });\n                                        } else if (type === \"log\") {\n                                            fire_event({\n                                                type: \"log\",\n                                                log: data2.log,\n                                                level: data2.level,\n                                                endpoint: _endpoint,\n                                                fn_index: fn_index\n                                            });\n                                            return;\n                                        } else if (type === \"generating\") {\n                                            fire_event({\n                                                type: \"status\",\n                                                time: /* @__PURE__ */ new Date(),\n                                                ...status2,\n                                                stage: status2 == null ? void 0 : status2.stage,\n                                                queue: true,\n                                                endpoint: _endpoint,\n                                                fn_index: fn_index\n                                            });\n                                            if (data2 && (protocol === \"sse_v2\" || protocol === \"sse_v2.1\")) apply_diff_stream(event_id, data2);\n                                        }\n                                        if (data2) {\n                                            fire_event({\n                                                type: \"data\",\n                                                time: /* @__PURE__ */ new Date(),\n                                                data: data2.data,\n                                                endpoint: _endpoint,\n                                                fn_index: fn_index\n                                            });\n                                            if (complete) fire_event({\n                                                type: \"status\",\n                                                time: /* @__PURE__ */ new Date(),\n                                                ...complete,\n                                                stage: status2 == null ? void 0 : status2.stage,\n                                                queue: true,\n                                                endpoint: _endpoint,\n                                                fn_index: fn_index\n                                            });\n                                        }\n                                        if ((status2 == null ? void 0 : status2.stage) === \"complete\" || (status2 == null ? void 0 : status2.stage) === \"error\") {\n                                            if (event_callbacks[event_id]) delete event_callbacks[event_id];\n                                            if (event_id in pending_diff_streams) delete pending_diff_streams[event_id];\n                                        }\n                                    } catch (e) {\n                                        console.error(\"Unexpected client exception\", e);\n                                        fire_event({\n                                            type: \"status\",\n                                            stage: \"error\",\n                                            message: \"An Unexpected Error Occurred!\",\n                                            queue: true,\n                                            endpoint: _endpoint,\n                                            fn_index: fn_index,\n                                            time: /* @__PURE__ */ new Date()\n                                        });\n                                        close_stream();\n                                    }\n                                };\n                                if (event_id in pending_stream_messages) {\n                                    pending_stream_messages[event_id].forEach((msg)=>callback(msg));\n                                    delete pending_stream_messages[event_id];\n                                }\n                                event_callbacks[event_id] = callback;\n                                unclosed_events.add(event_id);\n                                if (!stream_open) open_stream();\n                            }\n                        });\n                    }\n                });\n                function apply_diff_stream(event_id2, data2) {\n                    let is_first_generation = !pending_diff_streams[event_id2];\n                    if (is_first_generation) {\n                        pending_diff_streams[event_id2] = [];\n                        data2.data.forEach((value, i)=>{\n                            pending_diff_streams[event_id2][i] = value;\n                        });\n                    } else data2.data.forEach((value, i)=>{\n                        let new_data = $9b72dfb568173b1a$var$apply_diff(pending_diff_streams[event_id2][i], value);\n                        pending_diff_streams[event_id2][i] = new_data;\n                        data2.data[i] = new_data;\n                    });\n                }\n                function fire_event(event) {\n                    const narrowed_listener_map = listener_map;\n                    const listeners = narrowed_listener_map[event.type] || [];\n                    listeners == null || listeners.forEach((l)=>l(event));\n                }\n                function on(eventType, listener) {\n                    const narrowed_listener_map = listener_map;\n                    const listeners = narrowed_listener_map[eventType] || [];\n                    narrowed_listener_map[eventType] = listeners;\n                    listeners == null || listeners.push(listener);\n                    return {\n                        on: on,\n                        off: off,\n                        cancel: cancel,\n                        destroy: destroy\n                    };\n                }\n                function off(eventType, listener) {\n                    const narrowed_listener_map = listener_map;\n                    let listeners = narrowed_listener_map[eventType] || [];\n                    listeners = listeners == null ? void 0 : listeners.filter((l)=>l !== listener);\n                    narrowed_listener_map[eventType] = listeners;\n                    return {\n                        on: on,\n                        off: off,\n                        cancel: cancel,\n                        destroy: destroy\n                    };\n                }\n                async function cancel() {\n                    const _status = {\n                        stage: \"complete\",\n                        queue: false,\n                        time: /* @__PURE__ */ new Date()\n                    };\n                    complete = _status;\n                    fire_event({\n                        ..._status,\n                        type: \"status\",\n                        endpoint: _endpoint,\n                        fn_index: fn_index\n                    });\n                    let cancel_request = {};\n                    if (protocol === \"ws\") {\n                        if (websocket && websocket.readyState === 0) websocket.addEventListener(\"open\", ()=>{\n                            websocket.close();\n                        });\n                        else websocket.close();\n                        cancel_request = {\n                            fn_index: fn_index,\n                            session_hash: session_hash\n                        };\n                    } else {\n                        eventSource.close();\n                        cancel_request = {\n                            event_id: event_id\n                        };\n                    }\n                    try {\n                        await fetch_implementation(`${config.root}/reset`, {\n                            headers: {\n                                \"Content-Type\": \"application/json\"\n                            },\n                            method: \"POST\",\n                            body: JSON.stringify(cancel_request)\n                        });\n                    } catch (e) {\n                        console.warn(\"The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable.\");\n                    }\n                }\n                function destroy() {\n                    for(const event_type in listener_map)listener_map[event_type].forEach((fn2)=>{\n                        off(event_type, fn2);\n                    });\n                }\n                return {\n                    on: on,\n                    off: off,\n                    cancel: cancel,\n                    destroy: destroy\n                };\n            }\n            function open_stream() {\n                stream_open = true;\n                let params = new URLSearchParams({\n                    session_hash: session_hash\n                }).toString();\n                let url = new URL(`${config.root}/queue/data?${params}`);\n                event_stream = EventSource_factory(url);\n                event_stream.onmessage = async function(event) {\n                    let _data = JSON.parse(event.data);\n                    const event_id = _data.event_id;\n                    if (!event_id) await Promise.all(Object.keys(event_callbacks).map((event_id2)=>event_callbacks[event_id2](_data)));\n                    else if (event_callbacks[event_id]) {\n                        if (_data.msg === \"process_completed\") {\n                            unclosed_events.delete(event_id);\n                            if (unclosed_events.size === 0) close_stream();\n                        }\n                        let fn2 = event_callbacks[event_id];\n                        window.setTimeout(fn2, 0, _data);\n                    } else {\n                        if (!pending_stream_messages[event_id]) pending_stream_messages[event_id] = [];\n                        pending_stream_messages[event_id].push(_data);\n                    }\n                };\n                event_stream.onerror = async function(event) {\n                    await Promise.all(Object.keys(event_callbacks).map((event_id)=>event_callbacks[event_id]({\n                            msg: \"unexpected_error\",\n                            message: $9b72dfb568173b1a$var$BROKEN_CONNECTION_MSG\n                        })));\n                    close_stream();\n                };\n            }\n            function close_stream() {\n                stream_open = false;\n                event_stream == null || event_stream.close();\n            }\n            async function component_server(component_id, fn_name, data) {\n                var _a;\n                const headers = {\n                    \"Content-Type\": \"application/json\"\n                };\n                if (hf_token) headers.Authorization = `Bearer ${hf_token}`;\n                let root_url;\n                let component = config.components.find((comp)=>comp.id === component_id);\n                if ((_a = component == null ? void 0 : component.props) == null ? void 0 : _a.root_url) root_url = component.props.root_url;\n                else root_url = config.root;\n                const response = await fetch_implementation(`${root_url}/component_server/`, {\n                    method: \"POST\",\n                    body: JSON.stringify({\n                        data: data,\n                        component_id: component_id,\n                        fn_name: fn_name,\n                        session_hash: session_hash\n                    }),\n                    headers: headers\n                });\n                if (!response.ok) throw new Error(\"Could not connect to component server: \" + response.statusText);\n                const output = await response.json();\n                return output;\n            }\n            async function view_api(config2) {\n                if (api) return api;\n                const headers = {\n                    \"Content-Type\": \"application/json\"\n                };\n                if (hf_token) headers.Authorization = `Bearer ${hf_token}`;\n                let response;\n                if ($9b72dfb568173b1a$var$semiver(config2.version || \"2.0.0\", \"3.30\") < 0) response = await fetch_implementation(\"https://gradio-space-api-fetcher-v2.hf.space/api\", {\n                    method: \"POST\",\n                    body: JSON.stringify({\n                        serialize: false,\n                        config: JSON.stringify(config2)\n                    }),\n                    headers: headers\n                });\n                else response = await fetch_implementation(`${config2.root}/info`, {\n                    headers: headers\n                });\n                if (!response.ok) throw new Error($9b72dfb568173b1a$var$BROKEN_CONNECTION_MSG);\n                let api_info = await response.json();\n                if (\"api\" in api_info) api_info = api_info.api;\n                if (api_info.named_endpoints[\"/predict\"] && !api_info.unnamed_endpoints[\"0\"]) api_info.unnamed_endpoints[0] = api_info.named_endpoints[\"/predict\"];\n                const x = $9b72dfb568173b1a$var$transform_api_info(api_info, config2, api_map);\n                return x;\n            }\n        });\n    }\n    async function handle_blob2(endpoint, data, api_info, token) {\n        const blob_refs = await $9b72dfb568173b1a$var$walk_and_store_blobs(data, void 0, [], true, api_info);\n        return Promise.all(blob_refs.map(async ({ path: path, blob: blob, type: type })=>{\n            if (blob) {\n                const file_url = (await upload_files2(endpoint, [\n                    blob\n                ], token)).files[0];\n                return {\n                    path: path,\n                    file_url: file_url,\n                    type: type,\n                    name: blob == null ? void 0 : blob.name\n                };\n            }\n            return {\n                path: path,\n                type: type\n            };\n        })).then((r)=>{\n            r.forEach(({ path: path, file_url: file_url, type: type, name: name })=>{\n                if (type === \"Gallery\") $9b72dfb568173b1a$var$update_object(data, file_url, path);\n                else if (file_url) {\n                    const file = new $9b72dfb568173b1a$export$aa5a39f77f24e0c0({\n                        path: file_url,\n                        orig_name: name\n                    });\n                    $9b72dfb568173b1a$var$update_object(data, file, path);\n                }\n            });\n            return data;\n        });\n    }\n}\nconst { post_data: $9b72dfb568173b1a$export$95aa8a13ede09e64, upload_files: $9b72dfb568173b1a$export$db33103a2a87725a, client: $9b72dfb568173b1a$export$388e0302ca0d9a41, handle_blob: $9b72dfb568173b1a$var$handle_blob } = $9b72dfb568173b1a$export$e70d99f56c8376bd(fetch, (...args)=>new EventSource(...args));\nfunction $9b72dfb568173b1a$var$get_type(type, component, serializer, signature_type) {\n    switch(type.type){\n        case \"string\":\n            return \"string\";\n        case \"boolean\":\n            return \"boolean\";\n        case \"number\":\n            return \"number\";\n    }\n    if (serializer === \"JSONSerializable\" || serializer === \"StringSerializable\") return \"any\";\n    else if (serializer === \"ListStringSerializable\") return \"string[]\";\n    else if (component === \"Image\") return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : \"string\";\n    else if (serializer === \"FileSerializable\") {\n        if ((type == null ? void 0 : type.type) === \"array\") return signature_type === \"parameter\" ? \"(Blob | File | Buffer)[]\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]`;\n        return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}`;\n    } else if (serializer === \"GallerySerializable\") return signature_type === \"parameter\" ? \"[(Blob | File | Buffer), (string | null)][]\" : `[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]`;\n}\nfunction $9b72dfb568173b1a$var$get_description(type, serializer) {\n    if (serializer === \"GallerySerializable\") return \"array of [file, label] tuples\";\n    else if (serializer === \"ListStringSerializable\") return \"array of strings\";\n    else if (serializer === \"FileSerializable\") return \"array of files or single file\";\n    return type.description;\n}\nfunction $9b72dfb568173b1a$var$transform_api_info(api_info, config, api_map) {\n    const new_data = {\n        named_endpoints: {},\n        unnamed_endpoints: {}\n    };\n    for(const key in api_info){\n        const cat = api_info[key];\n        for(const endpoint in cat){\n            const dep_index = config.dependencies[endpoint] ? endpoint : api_map[endpoint.replace(\"/\", \"\")];\n            const info = cat[endpoint];\n            new_data[key][endpoint] = {};\n            new_data[key][endpoint].parameters = {};\n            new_data[key][endpoint].returns = {};\n            new_data[key][endpoint].type = config.dependencies[dep_index].types;\n            new_data[key][endpoint].parameters = info.parameters.map(({ label: label, component: component, type: type, serializer: serializer })=>({\n                    label: label,\n                    component: component,\n                    type: $9b72dfb568173b1a$var$get_type(type, component, serializer, \"parameter\"),\n                    description: $9b72dfb568173b1a$var$get_description(type, serializer)\n                }));\n            new_data[key][endpoint].returns = info.returns.map(({ label: label, component: component, type: type, serializer: serializer })=>({\n                    label: label,\n                    component: component,\n                    type: $9b72dfb568173b1a$var$get_type(type, component, serializer, \"return\"),\n                    description: $9b72dfb568173b1a$var$get_description(type, serializer)\n                }));\n        }\n    }\n    return new_data;\n}\nasync function $9b72dfb568173b1a$var$get_jwt(space, token) {\n    try {\n        const r = await fetch(`https://huggingface.co/api/spaces/${space}/jwt`, {\n            headers: {\n                Authorization: `Bearer ${token}`\n            }\n        });\n        const jwt = (await r.json()).token;\n        return jwt || false;\n    } catch (e) {\n        console.error(e);\n        return false;\n    }\n}\nfunction $9b72dfb568173b1a$var$update_object(object, newValue, stack) {\n    while(stack.length > 1)object = object[stack.shift()];\n    object[stack.shift()] = newValue;\n}\nasync function $9b72dfb568173b1a$var$walk_and_store_blobs(param, type, path = [], root = false, api_info) {\n    if (Array.isArray(param)) {\n        let blob_refs = [];\n        await Promise.all(param.map(async (v, i)=>{\n            var _a;\n            let new_path = path.slice();\n            new_path.push(i);\n            const array_refs = await $9b72dfb568173b1a$var$walk_and_store_blobs(param[i], root ? ((_a = api_info == null ? void 0 : api_info.parameters[i]) == null ? void 0 : _a.component) || void 0 : type, new_path, false, api_info);\n            blob_refs = blob_refs.concat(array_refs);\n        }));\n        return blob_refs;\n    } else if (globalThis.Buffer && param instanceof globalThis.Buffer) {\n        const is_image = type === \"Image\";\n        return [\n            {\n                path: path,\n                blob: is_image ? false : new $9b72dfb568173b1a$var$NodeBlob([\n                    param\n                ]),\n                type: type\n            }\n        ];\n    } else if (typeof param === \"object\") {\n        let blob_refs = [];\n        for(let key in param)if (param.hasOwnProperty(key)) {\n            let new_path = path.slice();\n            new_path.push(key);\n            blob_refs = blob_refs.concat(await $9b72dfb568173b1a$var$walk_and_store_blobs(param[key], void 0, new_path, false, api_info));\n        }\n        return blob_refs;\n    }\n    return [];\n}\nfunction $9b72dfb568173b1a$var$skip_queue(id, config) {\n    var _a, _b, _c, _d;\n    return !(((_b = (_a = config == null ? void 0 : config.dependencies) == null ? void 0 : _a[id]) == null ? void 0 : _b.queue) === null ? config.enable_queue : (_d = (_c = config == null ? void 0 : config.dependencies) == null ? void 0 : _c[id]) == null ? void 0 : _d.queue) || false;\n}\nasync function $9b72dfb568173b1a$var$resolve_config(fetch_implementation, endpoint, token) {\n    const headers = {};\n    if (token) headers.Authorization = `Bearer ${token}`;\n    if (typeof window !== \"undefined\" && window.gradio_config && location.origin !== \"http://localhost:9876\" && !window.gradio_config.dev_mode) {\n        const path = window.gradio_config.root;\n        const config = window.gradio_config;\n        config.root = $9b72dfb568173b1a$var$resolve_root(endpoint, config.root, false);\n        return {\n            ...config,\n            path: path\n        };\n    } else if (endpoint) {\n        let response = await fetch_implementation(`${endpoint}/config`, {\n            headers: headers\n        });\n        if (response.status === 200) {\n            const config = await response.json();\n            config.path = config.path ?? \"\";\n            config.root = endpoint;\n            return config;\n        }\n        throw new Error(\"Could not get config.\");\n    }\n    throw new Error(\"No config or app endpoint found\");\n}\nasync function $9b72dfb568173b1a$var$check_space_status(id, type, status_callback) {\n    let endpoint = type === \"subdomain\" ? `https://huggingface.co/api/spaces/by-subdomain/${id}` : `https://huggingface.co/api/spaces/${id}`;\n    let response;\n    let _status;\n    try {\n        response = await fetch(endpoint);\n        _status = response.status;\n        if (_status !== 200) throw new Error();\n        response = await response.json();\n    } catch (e) {\n        status_callback({\n            status: \"error\",\n            load_status: \"error\",\n            message: \"Could not get space status\",\n            detail: \"NOT_FOUND\"\n        });\n        return;\n    }\n    if (!response || _status !== 200) return;\n    const { runtime: { stage: stage }, id: space_name } = response;\n    switch(stage){\n        case \"STOPPED\":\n        case \"SLEEPING\":\n            status_callback({\n                status: \"sleeping\",\n                load_status: \"pending\",\n                message: \"Space is asleep. Waking it up...\",\n                detail: stage\n            });\n            setTimeout(()=>{\n                $9b72dfb568173b1a$var$check_space_status(id, type, status_callback);\n            }, 1e3);\n            break;\n        case \"PAUSED\":\n            status_callback({\n                status: \"paused\",\n                load_status: \"error\",\n                message: \"This space has been paused by the author. If you would like to try this demo, consider duplicating the space.\",\n                detail: stage,\n                discussions_enabled: await $9b72dfb568173b1a$var$discussions_enabled(space_name)\n            });\n            break;\n        case \"RUNNING\":\n        case \"RUNNING_BUILDING\":\n            status_callback({\n                status: \"running\",\n                load_status: \"complete\",\n                message: \"\",\n                detail: stage\n            });\n            break;\n        case \"BUILDING\":\n            status_callback({\n                status: \"building\",\n                load_status: \"pending\",\n                message: \"Space is building...\",\n                detail: stage\n            });\n            setTimeout(()=>{\n                $9b72dfb568173b1a$var$check_space_status(id, type, status_callback);\n            }, 1e3);\n            break;\n        default:\n            status_callback({\n                status: \"space_error\",\n                load_status: \"error\",\n                message: \"This space is experiencing an issue.\",\n                detail: stage,\n                discussions_enabled: await $9b72dfb568173b1a$var$discussions_enabled(space_name)\n            });\n            break;\n    }\n}\nfunction $9b72dfb568173b1a$var$handle_message(data, last_status) {\n    const queue = true;\n    switch(data.msg){\n        case \"send_data\":\n            return {\n                type: \"data\"\n            };\n        case \"send_hash\":\n            return {\n                type: \"hash\"\n            };\n        case \"queue_full\":\n            return {\n                type: \"update\",\n                status: {\n                    queue: queue,\n                    message: $9b72dfb568173b1a$var$QUEUE_FULL_MSG,\n                    stage: \"error\",\n                    code: data.code,\n                    success: data.success\n                }\n            };\n        case \"heartbeat\":\n            return {\n                type: \"heartbeat\"\n            };\n        case \"unexpected_error\":\n            return {\n                type: \"unexpected_error\",\n                status: {\n                    queue: queue,\n                    message: data.message,\n                    stage: \"error\",\n                    success: false\n                }\n            };\n        case \"estimation\":\n            return {\n                type: \"update\",\n                status: {\n                    queue: queue,\n                    stage: last_status || \"pending\",\n                    code: data.code,\n                    size: data.queue_size,\n                    position: data.rank,\n                    eta: data.rank_eta,\n                    success: data.success\n                }\n            };\n        case \"progress\":\n            return {\n                type: \"update\",\n                status: {\n                    queue: queue,\n                    stage: \"pending\",\n                    code: data.code,\n                    progress_data: data.progress_data,\n                    success: data.success\n                }\n            };\n        case \"log\":\n            return {\n                type: \"log\",\n                data: data\n            };\n        case \"process_generating\":\n            return {\n                type: \"generating\",\n                status: {\n                    queue: queue,\n                    message: !data.success ? data.output.error : null,\n                    stage: data.success ? \"generating\" : \"error\",\n                    code: data.code,\n                    progress_data: data.progress_data,\n                    eta: data.average_duration\n                },\n                data: data.success ? data.output : null\n            };\n        case \"process_completed\":\n            if (\"error\" in data.output) return {\n                type: \"update\",\n                status: {\n                    queue: queue,\n                    message: data.output.error,\n                    stage: \"error\",\n                    code: data.code,\n                    success: data.success\n                }\n            };\n            return {\n                type: \"complete\",\n                status: {\n                    queue: queue,\n                    message: !data.success ? data.output.error : void 0,\n                    stage: data.success ? \"complete\" : \"error\",\n                    code: data.code,\n                    progress_data: data.progress_data\n                },\n                data: data.success ? data.output : null\n            };\n        case \"process_starts\":\n            return {\n                type: \"update\",\n                status: {\n                    queue: queue,\n                    stage: \"pending\",\n                    code: data.code,\n                    size: data.rank,\n                    position: 0,\n                    success: data.success,\n                    eta: data.eta\n                }\n            };\n    }\n    return {\n        type: \"none\",\n        status: {\n            stage: \"error\",\n            queue: queue\n        }\n    };\n}\n\n\nconst $b63be9b0371e788c$var$submit = document.getElementById(\"predict-button\");\nconst $b63be9b0371e788c$var$drag_over = document.getElementById(\"drop_zone\");\nconst $b63be9b0371e788c$var$upload_input = document.getElementById(\"input_photo\");\nconst $b63be9b0371e788c$var$image_zone = document.getElementById(\"drop_zone\");\nconst $b63be9b0371e788c$var$upload_image = document.getElementById(\"upload_image\");\nconst $b63be9b0371e788c$var$upload_title = document.getElementById(\"upload_title\");\nlet $b63be9b0371e788c$var$file;\nasync function $b63be9b0371e788c$var$makePrediction(file) {\n    try {\n        const app = await (0, $9b72dfb568173b1a$export$388e0302ca0d9a41)(\"airvit2/pet_classifier\");\n        const result = await app.predict(\"/predict\", [\n            file\n        ]);\n        console.log(\"Prediction successful\");\n        console.log(result.data);\n    } catch (error) {\n        console.log(\"An error occurred during prediction\");\n        console.error(error);\n    }\n}\nfunction $b63be9b0371e788c$var$addImage(fl) {\n    const bgUrl = URL.createObjectURL(fl);\n    $b63be9b0371e788c$var$image_zone.classList.add(\"bg-cover\");\n    $b63be9b0371e788c$var$image_zone.classList.add(\"bg-center\");\n    $b63be9b0371e788c$var$image_zone.classList.add(\"bg-no-repeat\");\n    $b63be9b0371e788c$var$image_zone.style.backgroundImage = `url(${bgUrl})`;\n    $b63be9b0371e788c$var$upload_image.classList.add(\"hidden\");\n    $b63be9b0371e788c$var$upload_title.classList.add(\"hidden\");\n    $b63be9b0371e788c$var$file = fl;\n}\nfunction $b63be9b0371e788c$var$removeImage() {\n    $b63be9b0371e788c$var$image_zone.classList.remove(\"bg-cover\");\n    $b63be9b0371e788c$var$image_zone.classList.remove(\"bg-center\");\n    $b63be9b0371e788c$var$image_zone.classList.remove(\"bg-no-repeat\");\n    $b63be9b0371e788c$var$image_zone.style.backgroundImage = \"\";\n    $b63be9b0371e788c$var$upload_image.classList.remove(\"hidden\");\n    $b63be9b0371e788c$var$upload_title.classList.remove(\"hidden\");\n}\nfunction $b63be9b0371e788c$var$dropHandler(e) {\n    e.preventDefault();\n    $b63be9b0371e788c$var$removeImage();\n    if (e.dataTransfer.items) [\n        ...e.dataTransfer.items\n    ].forEach((item, i)=>{\n        if (item.kind == \"file\") {\n            $b63be9b0371e788c$var$file = item.getAsFile();\n            $b63be9b0371e788c$var$addImage($b63be9b0371e788c$var$file);\n        }\n    });\n    else [\n        ...e.dataTransfer.files\n    ].forEach((file, i)=>{\n        console.log(`FILES  file[${i}].name = ${file.name}`);\n    });\n}\nfunction $b63be9b0371e788c$var$dragOverHandler(e) {\n    console.log(\"File(s) in drop zone\");\n    e.preventDefault();\n}\nfunction $b63be9b0371e788c$var$handleImageSelect(e) {\n    const files = e.target.files;\n    const file = files[0];\n    const reader = new FileReader();\n    const onReaderLoad = (file)=>{\n        $b63be9b0371e788c$var$removeImage();\n        $b63be9b0371e788c$var$addImage(file);\n    };\n    reader.onload = onReaderLoad(file);\n    reader.readAsText(file);\n}\nfunction $b63be9b0371e788c$var$onClickHandler(e) {\n    const input = document.getElementById(\"input_photo\");\n    input.click();\n}\nfunction $b63be9b0371e788c$var$onClickPredict(e) {\n    e.preventDefault();\n    $b63be9b0371e788c$var$makePrediction($b63be9b0371e788c$var$file);\n}\n$b63be9b0371e788c$var$upload_input.addEventListener(\"change\", $b63be9b0371e788c$var$handleImageSelect, false);\n$b63be9b0371e788c$var$submit.addEventListener(\"click\", $b63be9b0371e788c$var$onClickPredict);\n$b63be9b0371e788c$var$drag_over.addEventListener(\"drop\", $b63be9b0371e788c$var$dropHandler);\n$b63be9b0371e788c$var$drag_over.addEventListener(\"dragover\", $b63be9b0371e788c$var$dragOverHandler);\n$b63be9b0371e788c$var$drag_over.addEventListener(\"click\", $b63be9b0371e788c$var$onClickHandler);\n\n\n//# sourceMappingURL=index.f2ad3f5c.js.map\n","\"use strict\";\n\nvar mapping = new Map();\nfunction register(baseUrl, manifest) {\n  for (var i = 0; i < manifest.length - 1; i += 2) {\n    mapping.set(manifest[i], {\n      baseUrl: baseUrl,\n      path: manifest[i + 1]\n    });\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping.get(id);\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return new URL(resolved.path, resolved.baseUrl).toString();\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = Promise.all([load(\"gan9g\"), load(\"b9Ask\")]).then(() => parcelRequire('42ZAn'));","\"use strict\";\n\nfunction load(id) {\n  // eslint-disable-next-line no-undef\n  return __parcel__import__(require('../bundle-manifest').resolve(id));\n}\nmodule.exports = load;","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = (load(\"gan9g\")).then(() => parcelRequire('6ZWSX'));","require('./helpers/bundle-manifest').register(new __parcel__URL__(\"\").toString(),JSON.parse(\"[\\\"kb9mm\\\",\\\"index.f2ad3f5c.js\\\",\\\"b9Ask\\\",\\\"wrapper-6f348d45.b164e76d.js\\\",\\\"gan9g\\\",\\\"buffer.d9bd03a9.js\\\"]\"));","import { client, upload } from \"@gradio/client\";\r\n\r\nconst submit = document.getElementById(\"predict-button\");\r\nconst drag_over = document.getElementById(\"drop_zone\");\r\nconst upload_input = document.getElementById(\"input_photo\");\r\n\r\nconst image_zone = document.getElementById(\"drop_zone\");\r\nconst upload_image = document.getElementById(\"upload_image\");\r\nconst upload_title = document.getElementById(\"upload_title\");\r\nlet file;\r\n\r\nasync function makePrediction(file) {\r\n  try {\r\n    const app = await client(\"airvit2/pet_classifier\");\r\n    const result = await app.predict(\"/predict\", [file]);\r\n    console.log(\"Prediction successful\");\r\n    console.log(result.data);\r\n  } catch (error) {\r\n    console.log(\"An error occurred during prediction\");\r\n    console.error(error);\r\n  }\r\n}\r\n\r\nfunction addImage(fl) {\r\n  const bgUrl = URL.createObjectURL(fl);\r\n\r\n  image_zone.classList.add(\"bg-cover\");\r\n  image_zone.classList.add(\"bg-center\");\r\n  image_zone.classList.add(\"bg-no-repeat\");\r\n  image_zone.style.backgroundImage = `url(${bgUrl})`;\r\n\r\n  upload_image.classList.add(\"hidden\");\r\n  upload_title.classList.add(\"hidden\");\r\n\r\n  file = fl;\r\n}\r\n\r\nfunction removeImage() {\r\n  image_zone.classList.remove(\"bg-cover\");\r\n  image_zone.classList.remove(\"bg-center\");\r\n  image_zone.classList.remove(\"bg-no-repeat\");\r\n  image_zone.style.backgroundImage = \"\";\r\n\r\n  upload_image.classList.remove(\"hidden\");\r\n  upload_title.classList.remove(\"hidden\");\r\n}\r\n\r\nfunction dropHandler(e) {\r\n  e.preventDefault();\r\n  removeImage();\r\n  if (e.dataTransfer.items) {\r\n    [...e.dataTransfer.items].forEach((item, i) => {\r\n      if (item.kind == \"file\") {\r\n        file = item.getAsFile();\r\n        addImage(file);\r\n      }\r\n    });\r\n  } else {\r\n    [...e.dataTransfer.files].forEach((file, i) => {\r\n      console.log(`FILES  file[${i}].name = ${file.name}`);\r\n    });\r\n  }\r\n}\r\n\r\nfunction dragOverHandler(e) {\r\n  console.log(\"File(s) in drop zone\");\r\n  e.preventDefault();\r\n}\r\n\r\nfunction handleImageSelect(e) {\r\n  const files = e.target.files;\r\n  const file = files[0];\r\n  const reader = new FileReader();\r\n  const onReaderLoad = (file) => {\r\n    removeImage();\r\n    addImage(file);\r\n  };\r\n\r\n  reader.onload = onReaderLoad(file);\r\n  reader.readAsText(file);\r\n}\r\n\r\nfunction onClickHandler(e) {\r\n  const input = document.getElementById(\"input_photo\");\r\n  input.click();\r\n}\r\n\r\nfunction onClickPredict(e) {\r\n  e.preventDefault();\r\n  makePrediction(file);\r\n}\r\n\r\nupload_input.addEventListener(\"change\", handleImageSelect, false);\r\nsubmit.addEventListener(\"click\", onClickPredict);\r\ndrag_over.addEventListener(\"drop\", dropHandler);\r\ndrag_over.addEventListener(\"dragover\", dragOverHandler);\r\ndrag_over.addEventListener(\"click\", onClickHandler);\r\n","var fn = new Intl.Collator(0, { numeric: 1 }).compare;\nfunction semiver(a, b, bool) {\n  a = a.split(\".\");\n  b = b.split(\".\");\n  return fn(a[0], b[0]) || fn(a[1], b[1]) || (b[2] = b.slice(2).join(\".\"), bool = /[.-]/.test(a[2] = a.slice(2).join(\".\")), bool == /[.-]/.test(b[2]) ? fn(a[2], b[2]) : bool ? -1 : 1);\n}\nfunction resolve_root(base_url, root_path, prioritize_base) {\n  if (root_path.startsWith(\"http://\") || root_path.startsWith(\"https://\")) {\n    return prioritize_base ? base_url : root_path;\n  }\n  return base_url + root_path;\n}\nfunction determine_protocol(endpoint) {\n  if (endpoint.startsWith(\"http\")) {\n    const { protocol, host } = new URL(endpoint);\n    if (host.endsWith(\"hf.space\")) {\n      return {\n        ws_protocol: \"wss\",\n        host,\n        http_protocol: protocol\n      };\n    }\n    return {\n      ws_protocol: protocol === \"https:\" ? \"wss\" : \"ws\",\n      http_protocol: protocol,\n      host\n    };\n  } else if (endpoint.startsWith(\"file:\")) {\n    return {\n      ws_protocol: \"ws\",\n      http_protocol: \"http:\",\n      host: \"lite.local\"\n      // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.\n    };\n  }\n  return {\n    ws_protocol: \"wss\",\n    http_protocol: \"https:\",\n    host: endpoint\n  };\n}\nconst RE_SPACE_NAME = /^[^\\/]*\\/[^\\/]*$/;\nconst RE_SPACE_DOMAIN = /.*hf\\.space\\/{0,1}$/;\nasync function process_endpoint(app_reference, token) {\n  const headers = {};\n  if (token) {\n    headers.Authorization = `Bearer ${token}`;\n  }\n  const _app_reference = app_reference.trim();\n  if (RE_SPACE_NAME.test(_app_reference)) {\n    try {\n      const res = await fetch(\n        `https://huggingface.co/api/spaces/${_app_reference}/host`,\n        { headers }\n      );\n      if (res.status !== 200)\n        throw new Error(\"Space metadata could not be loaded.\");\n      const _host = (await res.json()).host;\n      return {\n        space_id: app_reference,\n        ...determine_protocol(_host)\n      };\n    } catch (e) {\n      throw new Error(\"Space metadata could not be loaded.\" + e.message);\n    }\n  }\n  if (RE_SPACE_DOMAIN.test(_app_reference)) {\n    const { ws_protocol, http_protocol, host } = determine_protocol(_app_reference);\n    return {\n      space_id: host.replace(\".hf.space\", \"\"),\n      ws_protocol,\n      http_protocol,\n      host\n    };\n  }\n  return {\n    space_id: false,\n    ...determine_protocol(_app_reference)\n  };\n}\nfunction map_names_to_ids(fns) {\n  let apis = {};\n  fns.forEach(({ api_name }, i) => {\n    if (api_name)\n      apis[api_name] = i;\n  });\n  return apis;\n}\nconst RE_DISABLED_DISCUSSION = /^(?=[^]*\\b[dD]iscussions{0,1}\\b)(?=[^]*\\b[dD]isabled\\b)[^]*$/;\nasync function discussions_enabled(space_id) {\n  try {\n    const r = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/discussions`,\n      {\n        method: \"HEAD\"\n      }\n    );\n    const error = r.headers.get(\"x-error-message\");\n    if (error && RE_DISABLED_DISCUSSION.test(error))\n      return false;\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nasync function get_space_hardware(space_id, token) {\n  const headers = {};\n  if (token) {\n    headers.Authorization = `Bearer ${token}`;\n  }\n  try {\n    const res = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/runtime`,\n      { headers }\n    );\n    if (res.status !== 200)\n      throw new Error(\"Space hardware could not be obtained.\");\n    const { hardware } = await res.json();\n    return hardware;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nasync function set_space_hardware(space_id, new_hardware, token) {\n  const headers = {};\n  if (token) {\n    headers.Authorization = `Bearer ${token}`;\n  }\n  try {\n    const res = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/hardware`,\n      { headers, body: JSON.stringify(new_hardware) }\n    );\n    if (res.status !== 200)\n      throw new Error(\n        \"Space hardware could not be set. Please ensure the space hardware provided is valid and that a Hugging Face token is passed in.\"\n      );\n    const { hardware } = await res.json();\n    return hardware;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nasync function set_space_timeout(space_id, timeout, token) {\n  const headers = {};\n  if (token) {\n    headers.Authorization = `Bearer ${token}`;\n  }\n  try {\n    const res = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/hardware`,\n      { headers, body: JSON.stringify({ seconds: timeout }) }\n    );\n    if (res.status !== 200)\n      throw new Error(\n        \"Space hardware could not be set. Please ensure the space hardware provided is valid and that a Hugging Face token is passed in.\"\n      );\n    const { hardware } = await res.json();\n    return hardware;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nconst hardware_types = [\n  \"cpu-basic\",\n  \"cpu-upgrade\",\n  \"t4-small\",\n  \"t4-medium\",\n  \"a10g-small\",\n  \"a10g-large\",\n  \"a100-large\"\n];\nfunction apply_edit(target, path, action, value) {\n  if (path.length === 0) {\n    if (action === \"replace\") {\n      return value;\n    } else if (action === \"append\") {\n      return target + value;\n    }\n    throw new Error(`Unsupported action: ${action}`);\n  }\n  let current = target;\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]];\n  }\n  const last_path = path[path.length - 1];\n  switch (action) {\n    case \"replace\":\n      current[last_path] = value;\n      break;\n    case \"append\":\n      current[last_path] += value;\n      break;\n    case \"add\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 0, value);\n      } else {\n        current[last_path] = value;\n      }\n      break;\n    case \"delete\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 1);\n      } else {\n        delete current[last_path];\n      }\n      break;\n    default:\n      throw new Error(`Unknown action: ${action}`);\n  }\n  return target;\n}\nfunction apply_diff(obj, diff) {\n  diff.forEach(([action, path, value]) => {\n    obj = apply_edit(obj, path, action, value);\n  });\n  return obj;\n}\nasync function upload(file_data, root, upload_id, upload_fn = upload_files) {\n  let files = (Array.isArray(file_data) ? file_data : [file_data]).map(\n    (file_data2) => file_data2.blob\n  );\n  return await Promise.all(\n    await upload_fn(root, files, void 0, upload_id).then(\n      async (response) => {\n        if (response.error) {\n          throw new Error(response.error);\n        } else {\n          if (response.files) {\n            return response.files.map((f, i) => {\n              const file = new FileData({\n                ...file_data[i],\n                path: f,\n                url: root + \"/file=\" + f\n              });\n              return file;\n            });\n          }\n          return [];\n        }\n      }\n    )\n  );\n}\nasync function prepare_files(files, is_stream) {\n  return files.map(\n    (f, i) => new FileData({\n      path: f.name,\n      orig_name: f.name,\n      blob: f,\n      size: f.size,\n      mime_type: f.type,\n      is_stream\n    })\n  );\n}\nclass FileData {\n  constructor({\n    path,\n    url,\n    orig_name,\n    size,\n    blob,\n    is_stream,\n    mime_type,\n    alt_text\n  }) {\n    this.meta = { _type: \"gradio.FileData\" };\n    this.path = path;\n    this.url = url;\n    this.orig_name = orig_name;\n    this.size = size;\n    this.blob = url ? void 0 : blob;\n    this.is_stream = is_stream;\n    this.mime_type = mime_type;\n    this.alt_text = alt_text;\n  }\n}\nconst QUEUE_FULL_MSG = \"This application is too busy. Keep trying!\";\nconst BROKEN_CONNECTION_MSG = \"Connection errored out.\";\nlet NodeBlob;\nasync function duplicate(app_reference, options) {\n  const { hf_token, private: _private, hardware, timeout } = options;\n  if (hardware && !hardware_types.includes(hardware)) {\n    throw new Error(\n      `Invalid hardware type provided. Valid types are: ${hardware_types.map((v) => `\"${v}\"`).join(\",\")}.`\n    );\n  }\n  const headers = {\n    Authorization: `Bearer ${hf_token}`\n  };\n  const user = (await (await fetch(`https://huggingface.co/api/whoami-v2`, {\n    headers\n  })).json()).name;\n  const space_name = app_reference.split(\"/\")[1];\n  const body = {\n    repository: `${user}/${space_name}`\n  };\n  if (_private) {\n    body.private = true;\n  }\n  try {\n    const response = await fetch(\n      `https://huggingface.co/api/spaces/${app_reference}/duplicate`,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\", ...headers },\n        body: JSON.stringify(body)\n      }\n    );\n    if (response.status === 409) {\n      return client(`${user}/${space_name}`, options);\n    }\n    const duplicated_space = await response.json();\n    let original_hardware;\n    if (!hardware) {\n      original_hardware = await get_space_hardware(app_reference, hf_token);\n    }\n    const requested_hardware = hardware || original_hardware || \"cpu-basic\";\n    await set_space_hardware(\n      `${user}/${space_name}`,\n      requested_hardware,\n      hf_token\n    );\n    await set_space_timeout(`${user}/${space_name}`, timeout || 300, hf_token);\n    return client(duplicated_space.url, options);\n  } catch (e) {\n    throw new Error(e);\n  }\n}\nfunction api_factory(fetch_implementation, EventSource_factory) {\n  return { post_data: post_data2, upload_files: upload_files2, client: client2, handle_blob: handle_blob2 };\n  async function post_data2(url, body, token) {\n    const headers = { \"Content-Type\": \"application/json\" };\n    if (token) {\n      headers.Authorization = `Bearer ${token}`;\n    }\n    try {\n      var response = await fetch_implementation(url, {\n        method: \"POST\",\n        body: JSON.stringify(body),\n        headers\n      });\n    } catch (e) {\n      return [{ error: BROKEN_CONNECTION_MSG }, 500];\n    }\n    let output;\n    let status;\n    try {\n      output = await response.json();\n      status = response.status;\n    } catch (e) {\n      output = { error: `Could not parse server response: ${e}` };\n      status = 500;\n    }\n    return [output, status];\n  }\n  async function upload_files2(root, files, token, upload_id) {\n    const headers = {};\n    if (token) {\n      headers.Authorization = `Bearer ${token}`;\n    }\n    const chunkSize = 1e3;\n    const uploadResponses = [];\n    for (let i = 0; i < files.length; i += chunkSize) {\n      const chunk = files.slice(i, i + chunkSize);\n      const formData = new FormData();\n      chunk.forEach((file) => {\n        formData.append(\"files\", file);\n      });\n      try {\n        const upload_url = upload_id ? `${root}/upload?upload_id=${upload_id}` : `${root}/upload`;\n        var response = await fetch_implementation(upload_url, {\n          method: \"POST\",\n          body: formData,\n          headers\n        });\n      } catch (e) {\n        return { error: BROKEN_CONNECTION_MSG };\n      }\n      const output = await response.json();\n      uploadResponses.push(...output);\n    }\n    return { files: uploadResponses };\n  }\n  async function client2(app_reference, options = {}) {\n    return new Promise(async (res) => {\n      const { status_callback, hf_token } = options;\n      const return_obj = {\n        predict,\n        submit,\n        view_api,\n        component_server\n      };\n      if ((typeof window === \"undefined\" || !(\"WebSocket\" in window)) && !global.Websocket) {\n        const ws = await import(\"./wrapper-6f348d45.js\");\n        NodeBlob = (await import(\"node:buffer\")).Blob;\n        global.WebSocket = ws.WebSocket;\n      }\n      const { ws_protocol, http_protocol, host, space_id } = await process_endpoint(app_reference, hf_token);\n      const session_hash = Math.random().toString(36).substring(2);\n      const last_status = {};\n      let stream_open = false;\n      let pending_stream_messages = {};\n      let pending_diff_streams = {};\n      let event_stream = null;\n      const event_callbacks = {};\n      const unclosed_events = /* @__PURE__ */ new Set();\n      let config;\n      let api_map = {};\n      let jwt = false;\n      if (hf_token && space_id) {\n        jwt = await get_jwt(space_id, hf_token);\n      }\n      async function config_success(_config) {\n        config = _config;\n        if (window.location.protocol === \"https:\") {\n          config.root = config.root.replace(\"http://\", \"https://\");\n        }\n        api_map = map_names_to_ids((_config == null ? void 0 : _config.dependencies) || []);\n        if (config.auth_required) {\n          return {\n            config,\n            ...return_obj\n          };\n        }\n        try {\n          api = await view_api(config);\n        } catch (e) {\n          console.error(`Could not get api details: ${e.message}`);\n        }\n        return {\n          config,\n          ...return_obj\n        };\n      }\n      let api;\n      async function handle_space_sucess(status) {\n        if (status_callback)\n          status_callback(status);\n        if (status.status === \"running\")\n          try {\n            config = await resolve_config(\n              fetch_implementation,\n              `${http_protocol}//${host}`,\n              hf_token\n            );\n            const _config = await config_success(config);\n            res(_config);\n          } catch (e) {\n            console.error(e);\n            if (status_callback) {\n              status_callback({\n                status: \"error\",\n                message: \"Could not load this space.\",\n                load_status: \"error\",\n                detail: \"NOT_FOUND\"\n              });\n            }\n          }\n      }\n      try {\n        config = await resolve_config(\n          fetch_implementation,\n          `${http_protocol}//${host}`,\n          hf_token\n        );\n        const _config = await config_success(config);\n        res(_config);\n      } catch (e) {\n        console.error(e);\n        if (space_id) {\n          check_space_status(\n            space_id,\n            RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\",\n            handle_space_sucess\n          );\n        } else {\n          if (status_callback)\n            status_callback({\n              status: \"error\",\n              message: \"Could not load this space.\",\n              load_status: \"error\",\n              detail: \"NOT_FOUND\"\n            });\n        }\n      }\n      function predict(endpoint, data, event_data) {\n        let data_returned = false;\n        let status_complete = false;\n        let dependency;\n        if (typeof endpoint === \"number\") {\n          dependency = config.dependencies[endpoint];\n        } else {\n          const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n          dependency = config.dependencies[api_map[trimmed_endpoint]];\n        }\n        if (dependency.types.continuous) {\n          throw new Error(\n            \"Cannot call predict on this function as it may run forever. Use submit instead\"\n          );\n        }\n        return new Promise((res2, rej) => {\n          const app = submit(endpoint, data, event_data);\n          let result;\n          app.on(\"data\", (d) => {\n            if (status_complete) {\n              app.destroy();\n              res2(d);\n            }\n            data_returned = true;\n            result = d;\n          }).on(\"status\", (status) => {\n            if (status.stage === \"error\")\n              rej(status);\n            if (status.stage === \"complete\") {\n              status_complete = true;\n              if (data_returned) {\n                app.destroy();\n                res2(result);\n              }\n            }\n          });\n        });\n      }\n      function submit(endpoint, data, event_data, trigger_id = null) {\n        let fn_index;\n        let api_info;\n        if (typeof endpoint === \"number\") {\n          fn_index = endpoint;\n          api_info = api.unnamed_endpoints[fn_index];\n        } else {\n          const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n          fn_index = api_map[trimmed_endpoint];\n          api_info = api.named_endpoints[endpoint.trim()];\n        }\n        if (typeof fn_index !== \"number\") {\n          throw new Error(\n            \"There is no endpoint matching that name of fn_index matching that number.\"\n          );\n        }\n        let websocket;\n        let eventSource;\n        let protocol = config.protocol ?? \"ws\";\n        const _endpoint = typeof endpoint === \"number\" ? \"/predict\" : endpoint;\n        let payload;\n        let event_id = null;\n        let complete = false;\n        const listener_map = {};\n        let url_params = \"\";\n        if (typeof window !== \"undefined\") {\n          url_params = new URLSearchParams(window.location.search).toString();\n        }\n        handle_blob2(`${config.root}`, data, api_info, hf_token).then(\n          (_payload) => {\n            payload = {\n              data: _payload || [],\n              event_data,\n              fn_index,\n              trigger_id\n            };\n            if (skip_queue(fn_index, config)) {\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                stage: \"pending\",\n                queue: false,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n              post_data2(\n                `${config.root}/run${_endpoint.startsWith(\"/\") ? _endpoint : `/${_endpoint}`}${url_params ? \"?\" + url_params : \"\"}`,\n                {\n                  ...payload,\n                  session_hash\n                },\n                hf_token\n              ).then(([output, status_code]) => {\n                const data2 = output.data;\n                if (status_code == 200) {\n                  fire_event({\n                    type: \"data\",\n                    endpoint: _endpoint,\n                    fn_index,\n                    data: data2,\n                    time: /* @__PURE__ */ new Date()\n                  });\n                  fire_event({\n                    type: \"status\",\n                    endpoint: _endpoint,\n                    fn_index,\n                    stage: \"complete\",\n                    eta: output.average_duration,\n                    queue: false,\n                    time: /* @__PURE__ */ new Date()\n                  });\n                } else {\n                  fire_event({\n                    type: \"status\",\n                    stage: \"error\",\n                    endpoint: _endpoint,\n                    fn_index,\n                    message: output.error,\n                    queue: false,\n                    time: /* @__PURE__ */ new Date()\n                  });\n                }\n              }).catch((e) => {\n                fire_event({\n                  type: \"status\",\n                  stage: \"error\",\n                  message: e.message,\n                  endpoint: _endpoint,\n                  fn_index,\n                  queue: false,\n                  time: /* @__PURE__ */ new Date()\n                });\n              });\n            } else if (protocol == \"ws\") {\n              fire_event({\n                type: \"status\",\n                stage: \"pending\",\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n              let url = new URL(`${ws_protocol}://${resolve_root(\n                host,\n                config.path,\n                true\n              )}\n\t\t\t\t\t\t\t/queue/join${url_params ? \"?\" + url_params : \"\"}`);\n              if (jwt) {\n                url.searchParams.set(\"__sign\", jwt);\n              }\n              websocket = new WebSocket(url);\n              websocket.onclose = (evt) => {\n                if (!evt.wasClean) {\n                  fire_event({\n                    type: \"status\",\n                    stage: \"error\",\n                    broken: true,\n                    message: BROKEN_CONNECTION_MSG,\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */ new Date()\n                  });\n                }\n              };\n              websocket.onmessage = function(event) {\n                const _data = JSON.parse(event.data);\n                const { type, status, data: data2 } = handle_message(\n                  _data,\n                  last_status[fn_index]\n                );\n                if (type === \"update\" && status && !complete) {\n                  fire_event({\n                    type: \"status\",\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */ new Date(),\n                    ...status\n                  });\n                  if (status.stage === \"error\") {\n                    websocket.close();\n                  }\n                } else if (type === \"hash\") {\n                  websocket.send(JSON.stringify({ fn_index, session_hash }));\n                  return;\n                } else if (type === \"data\") {\n                  websocket.send(JSON.stringify({ ...payload, session_hash }));\n                } else if (type === \"complete\") {\n                  complete = status;\n                } else if (type === \"log\") {\n                  fire_event({\n                    type: \"log\",\n                    log: data2.log,\n                    level: data2.level,\n                    endpoint: _endpoint,\n                    fn_index\n                  });\n                } else if (type === \"generating\") {\n                  fire_event({\n                    type: \"status\",\n                    time: /* @__PURE__ */ new Date(),\n                    ...status,\n                    stage: status == null ? void 0 : status.stage,\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index\n                  });\n                }\n                if (data2) {\n                  fire_event({\n                    type: \"data\",\n                    time: /* @__PURE__ */ new Date(),\n                    data: data2.data,\n                    endpoint: _endpoint,\n                    fn_index\n                  });\n                  if (complete) {\n                    fire_event({\n                      type: \"status\",\n                      time: /* @__PURE__ */ new Date(),\n                      ...complete,\n                      stage: status == null ? void 0 : status.stage,\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    websocket.close();\n                  }\n                }\n              };\n              if (semiver(config.version || \"2.0.0\", \"3.6\") < 0) {\n                addEventListener(\n                  \"open\",\n                  () => websocket.send(JSON.stringify({ hash: session_hash }))\n                );\n              }\n            } else if (protocol == \"sse\") {\n              fire_event({\n                type: \"status\",\n                stage: \"pending\",\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n              var params = new URLSearchParams({\n                fn_index: fn_index.toString(),\n                session_hash\n              }).toString();\n              let url = new URL(\n                `${config.root}/queue/join?${url_params ? url_params + \"&\" : \"\"}${params}`\n              );\n              eventSource = EventSource_factory(url);\n              eventSource.onmessage = async function(event) {\n                const _data = JSON.parse(event.data);\n                const { type, status, data: data2 } = handle_message(\n                  _data,\n                  last_status[fn_index]\n                );\n                if (type === \"update\" && status && !complete) {\n                  fire_event({\n                    type: \"status\",\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */ new Date(),\n                    ...status\n                  });\n                  if (status.stage === \"error\") {\n                    eventSource.close();\n                  }\n                } else if (type === \"data\") {\n                  event_id = _data.event_id;\n                  let [_, status2] = await post_data2(\n                    `${config.root}/queue/data`,\n                    {\n                      ...payload,\n                      session_hash,\n                      event_id\n                    },\n                    hf_token\n                  );\n                  if (status2 !== 200) {\n                    fire_event({\n                      type: \"status\",\n                      stage: \"error\",\n                      message: BROKEN_CONNECTION_MSG,\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index,\n                      time: /* @__PURE__ */ new Date()\n                    });\n                    eventSource.close();\n                  }\n                } else if (type === \"complete\") {\n                  complete = status;\n                } else if (type === \"log\") {\n                  fire_event({\n                    type: \"log\",\n                    log: data2.log,\n                    level: data2.level,\n                    endpoint: _endpoint,\n                    fn_index\n                  });\n                } else if (type === \"generating\") {\n                  fire_event({\n                    type: \"status\",\n                    time: /* @__PURE__ */ new Date(),\n                    ...status,\n                    stage: status == null ? void 0 : status.stage,\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index\n                  });\n                }\n                if (data2) {\n                  fire_event({\n                    type: \"data\",\n                    time: /* @__PURE__ */ new Date(),\n                    data: data2.data,\n                    endpoint: _endpoint,\n                    fn_index\n                  });\n                  if (complete) {\n                    fire_event({\n                      type: \"status\",\n                      time: /* @__PURE__ */ new Date(),\n                      ...complete,\n                      stage: status == null ? void 0 : status.stage,\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    eventSource.close();\n                  }\n                }\n              };\n            } else if (protocol == \"sse_v1\" || protocol == \"sse_v2\" || protocol == \"sse_v2.1\") {\n              fire_event({\n                type: \"status\",\n                stage: \"pending\",\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n              post_data2(\n                `${config.root}/queue/join?${url_params}`,\n                {\n                  ...payload,\n                  session_hash\n                },\n                hf_token\n              ).then(([response, status]) => {\n                if (status === 503) {\n                  fire_event({\n                    type: \"status\",\n                    stage: \"error\",\n                    message: QUEUE_FULL_MSG,\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */ new Date()\n                  });\n                } else if (status !== 200) {\n                  fire_event({\n                    type: \"status\",\n                    stage: \"error\",\n                    message: BROKEN_CONNECTION_MSG,\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */ new Date()\n                  });\n                } else {\n                  event_id = response.event_id;\n                  let callback = async function(_data) {\n                    try {\n                      const { type, status: status2, data: data2 } = handle_message(\n                        _data,\n                        last_status[fn_index]\n                      );\n                      if (type == \"heartbeat\") {\n                        return;\n                      }\n                      if (type === \"update\" && status2 && !complete) {\n                        fire_event({\n                          type: \"status\",\n                          endpoint: _endpoint,\n                          fn_index,\n                          time: /* @__PURE__ */ new Date(),\n                          ...status2\n                        });\n                      } else if (type === \"complete\") {\n                        complete = status2;\n                      } else if (type == \"unexpected_error\") {\n                        console.error(\"Unexpected error\", status2 == null ? void 0 : status2.message);\n                        fire_event({\n                          type: \"status\",\n                          stage: \"error\",\n                          message: (status2 == null ? void 0 : status2.message) || \"An Unexpected Error Occurred!\",\n                          queue: true,\n                          endpoint: _endpoint,\n                          fn_index,\n                          time: /* @__PURE__ */ new Date()\n                        });\n                      } else if (type === \"log\") {\n                        fire_event({\n                          type: \"log\",\n                          log: data2.log,\n                          level: data2.level,\n                          endpoint: _endpoint,\n                          fn_index\n                        });\n                        return;\n                      } else if (type === \"generating\") {\n                        fire_event({\n                          type: \"status\",\n                          time: /* @__PURE__ */ new Date(),\n                          ...status2,\n                          stage: status2 == null ? void 0 : status2.stage,\n                          queue: true,\n                          endpoint: _endpoint,\n                          fn_index\n                        });\n                        if (data2 && (protocol === \"sse_v2\" || protocol === \"sse_v2.1\")) {\n                          apply_diff_stream(event_id, data2);\n                        }\n                      }\n                      if (data2) {\n                        fire_event({\n                          type: \"data\",\n                          time: /* @__PURE__ */ new Date(),\n                          data: data2.data,\n                          endpoint: _endpoint,\n                          fn_index\n                        });\n                        if (complete) {\n                          fire_event({\n                            type: \"status\",\n                            time: /* @__PURE__ */ new Date(),\n                            ...complete,\n                            stage: status2 == null ? void 0 : status2.stage,\n                            queue: true,\n                            endpoint: _endpoint,\n                            fn_index\n                          });\n                        }\n                      }\n                      if ((status2 == null ? void 0 : status2.stage) === \"complete\" || (status2 == null ? void 0 : status2.stage) === \"error\") {\n                        if (event_callbacks[event_id]) {\n                          delete event_callbacks[event_id];\n                        }\n                        if (event_id in pending_diff_streams) {\n                          delete pending_diff_streams[event_id];\n                        }\n                      }\n                    } catch (e) {\n                      console.error(\"Unexpected client exception\", e);\n                      fire_event({\n                        type: \"status\",\n                        stage: \"error\",\n                        message: \"An Unexpected Error Occurred!\",\n                        queue: true,\n                        endpoint: _endpoint,\n                        fn_index,\n                        time: /* @__PURE__ */ new Date()\n                      });\n                      close_stream();\n                    }\n                  };\n                  if (event_id in pending_stream_messages) {\n                    pending_stream_messages[event_id].forEach(\n                      (msg) => callback(msg)\n                    );\n                    delete pending_stream_messages[event_id];\n                  }\n                  event_callbacks[event_id] = callback;\n                  unclosed_events.add(event_id);\n                  if (!stream_open) {\n                    open_stream();\n                  }\n                }\n              });\n            }\n          }\n        );\n        function apply_diff_stream(event_id2, data2) {\n          let is_first_generation = !pending_diff_streams[event_id2];\n          if (is_first_generation) {\n            pending_diff_streams[event_id2] = [];\n            data2.data.forEach((value, i) => {\n              pending_diff_streams[event_id2][i] = value;\n            });\n          } else {\n            data2.data.forEach((value, i) => {\n              let new_data = apply_diff(\n                pending_diff_streams[event_id2][i],\n                value\n              );\n              pending_diff_streams[event_id2][i] = new_data;\n              data2.data[i] = new_data;\n            });\n          }\n        }\n        function fire_event(event) {\n          const narrowed_listener_map = listener_map;\n          const listeners = narrowed_listener_map[event.type] || [];\n          listeners == null ? void 0 : listeners.forEach((l) => l(event));\n        }\n        function on(eventType, listener) {\n          const narrowed_listener_map = listener_map;\n          const listeners = narrowed_listener_map[eventType] || [];\n          narrowed_listener_map[eventType] = listeners;\n          listeners == null ? void 0 : listeners.push(listener);\n          return { on, off, cancel, destroy };\n        }\n        function off(eventType, listener) {\n          const narrowed_listener_map = listener_map;\n          let listeners = narrowed_listener_map[eventType] || [];\n          listeners = listeners == null ? void 0 : listeners.filter((l) => l !== listener);\n          narrowed_listener_map[eventType] = listeners;\n          return { on, off, cancel, destroy };\n        }\n        async function cancel() {\n          const _status = {\n            stage: \"complete\",\n            queue: false,\n            time: /* @__PURE__ */ new Date()\n          };\n          complete = _status;\n          fire_event({\n            ..._status,\n            type: \"status\",\n            endpoint: _endpoint,\n            fn_index\n          });\n          let cancel_request = {};\n          if (protocol === \"ws\") {\n            if (websocket && websocket.readyState === 0) {\n              websocket.addEventListener(\"open\", () => {\n                websocket.close();\n              });\n            } else {\n              websocket.close();\n            }\n            cancel_request = { fn_index, session_hash };\n          } else {\n            eventSource.close();\n            cancel_request = { event_id };\n          }\n          try {\n            await fetch_implementation(`${config.root}/reset`, {\n              headers: { \"Content-Type\": \"application/json\" },\n              method: \"POST\",\n              body: JSON.stringify(cancel_request)\n            });\n          } catch (e) {\n            console.warn(\n              \"The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable.\"\n            );\n          }\n        }\n        function destroy() {\n          for (const event_type in listener_map) {\n            listener_map[event_type].forEach((fn2) => {\n              off(event_type, fn2);\n            });\n          }\n        }\n        return {\n          on,\n          off,\n          cancel,\n          destroy\n        };\n      }\n      function open_stream() {\n        stream_open = true;\n        let params = new URLSearchParams({\n          session_hash\n        }).toString();\n        let url = new URL(`${config.root}/queue/data?${params}`);\n        event_stream = EventSource_factory(url);\n        event_stream.onmessage = async function(event) {\n          let _data = JSON.parse(event.data);\n          const event_id = _data.event_id;\n          if (!event_id) {\n            await Promise.all(\n              Object.keys(event_callbacks).map(\n                (event_id2) => event_callbacks[event_id2](_data)\n              )\n            );\n          } else if (event_callbacks[event_id]) {\n            if (_data.msg === \"process_completed\") {\n              unclosed_events.delete(event_id);\n              if (unclosed_events.size === 0) {\n                close_stream();\n              }\n            }\n            let fn2 = event_callbacks[event_id];\n            window.setTimeout(fn2, 0, _data);\n          } else {\n            if (!pending_stream_messages[event_id]) {\n              pending_stream_messages[event_id] = [];\n            }\n            pending_stream_messages[event_id].push(_data);\n          }\n        };\n        event_stream.onerror = async function(event) {\n          await Promise.all(\n            Object.keys(event_callbacks).map(\n              (event_id) => event_callbacks[event_id]({\n                msg: \"unexpected_error\",\n                message: BROKEN_CONNECTION_MSG\n              })\n            )\n          );\n          close_stream();\n        };\n      }\n      function close_stream() {\n        stream_open = false;\n        event_stream == null ? void 0 : event_stream.close();\n      }\n      async function component_server(component_id, fn_name, data) {\n        var _a;\n        const headers = { \"Content-Type\": \"application/json\" };\n        if (hf_token) {\n          headers.Authorization = `Bearer ${hf_token}`;\n        }\n        let root_url;\n        let component = config.components.find(\n          (comp) => comp.id === component_id\n        );\n        if ((_a = component == null ? void 0 : component.props) == null ? void 0 : _a.root_url) {\n          root_url = component.props.root_url;\n        } else {\n          root_url = config.root;\n        }\n        const response = await fetch_implementation(\n          `${root_url}/component_server/`,\n          {\n            method: \"POST\",\n            body: JSON.stringify({\n              data,\n              component_id,\n              fn_name,\n              session_hash\n            }),\n            headers\n          }\n        );\n        if (!response.ok) {\n          throw new Error(\n            \"Could not connect to component server: \" + response.statusText\n          );\n        }\n        const output = await response.json();\n        return output;\n      }\n      async function view_api(config2) {\n        if (api)\n          return api;\n        const headers = { \"Content-Type\": \"application/json\" };\n        if (hf_token) {\n          headers.Authorization = `Bearer ${hf_token}`;\n        }\n        let response;\n        if (semiver(config2.version || \"2.0.0\", \"3.30\") < 0) {\n          response = await fetch_implementation(\n            \"https://gradio-space-api-fetcher-v2.hf.space/api\",\n            {\n              method: \"POST\",\n              body: JSON.stringify({\n                serialize: false,\n                config: JSON.stringify(config2)\n              }),\n              headers\n            }\n          );\n        } else {\n          response = await fetch_implementation(`${config2.root}/info`, {\n            headers\n          });\n        }\n        if (!response.ok) {\n          throw new Error(BROKEN_CONNECTION_MSG);\n        }\n        let api_info = await response.json();\n        if (\"api\" in api_info) {\n          api_info = api_info.api;\n        }\n        if (api_info.named_endpoints[\"/predict\"] && !api_info.unnamed_endpoints[\"0\"]) {\n          api_info.unnamed_endpoints[0] = api_info.named_endpoints[\"/predict\"];\n        }\n        const x = transform_api_info(api_info, config2, api_map);\n        return x;\n      }\n    });\n  }\n  async function handle_blob2(endpoint, data, api_info, token) {\n    const blob_refs = await walk_and_store_blobs(\n      data,\n      void 0,\n      [],\n      true,\n      api_info\n    );\n    return Promise.all(\n      blob_refs.map(async ({ path, blob, type }) => {\n        if (blob) {\n          const file_url = (await upload_files2(endpoint, [blob], token)).files[0];\n          return { path, file_url, type, name: blob == null ? void 0 : blob.name };\n        }\n        return { path, type };\n      })\n    ).then((r) => {\n      r.forEach(({ path, file_url, type, name }) => {\n        if (type === \"Gallery\") {\n          update_object(data, file_url, path);\n        } else if (file_url) {\n          const file = new FileData({ path: file_url, orig_name: name });\n          update_object(data, file, path);\n        }\n      });\n      return data;\n    });\n  }\n}\nconst { post_data, upload_files, client, handle_blob } = api_factory(\n  fetch,\n  (...args) => new EventSource(...args)\n);\nfunction get_type(type, component, serializer, signature_type) {\n  switch (type.type) {\n    case \"string\":\n      return \"string\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"number\":\n      return \"number\";\n  }\n  if (serializer === \"JSONSerializable\" || serializer === \"StringSerializable\") {\n    return \"any\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"string[]\";\n  } else if (component === \"Image\") {\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : \"string\";\n  } else if (serializer === \"FileSerializable\") {\n    if ((type == null ? void 0 : type.type) === \"array\") {\n      return signature_type === \"parameter\" ? \"(Blob | File | Buffer)[]\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]`;\n    }\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}`;\n  } else if (serializer === \"GallerySerializable\") {\n    return signature_type === \"parameter\" ? \"[(Blob | File | Buffer), (string | null)][]\" : `[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]`;\n  }\n}\nfunction get_description(type, serializer) {\n  if (serializer === \"GallerySerializable\") {\n    return \"array of [file, label] tuples\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"array of strings\";\n  } else if (serializer === \"FileSerializable\") {\n    return \"array of files or single file\";\n  }\n  return type.description;\n}\nfunction transform_api_info(api_info, config, api_map) {\n  const new_data = {\n    named_endpoints: {},\n    unnamed_endpoints: {}\n  };\n  for (const key in api_info) {\n    const cat = api_info[key];\n    for (const endpoint in cat) {\n      const dep_index = config.dependencies[endpoint] ? endpoint : api_map[endpoint.replace(\"/\", \"\")];\n      const info = cat[endpoint];\n      new_data[key][endpoint] = {};\n      new_data[key][endpoint].parameters = {};\n      new_data[key][endpoint].returns = {};\n      new_data[key][endpoint].type = config.dependencies[dep_index].types;\n      new_data[key][endpoint].parameters = info.parameters.map(\n        ({ label, component, type, serializer }) => ({\n          label,\n          component,\n          type: get_type(type, component, serializer, \"parameter\"),\n          description: get_description(type, serializer)\n        })\n      );\n      new_data[key][endpoint].returns = info.returns.map(\n        ({ label, component, type, serializer }) => ({\n          label,\n          component,\n          type: get_type(type, component, serializer, \"return\"),\n          description: get_description(type, serializer)\n        })\n      );\n    }\n  }\n  return new_data;\n}\nasync function get_jwt(space, token) {\n  try {\n    const r = await fetch(`https://huggingface.co/api/spaces/${space}/jwt`, {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n    const jwt = (await r.json()).token;\n    return jwt || false;\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\nfunction update_object(object, newValue, stack) {\n  while (stack.length > 1) {\n    object = object[stack.shift()];\n  }\n  object[stack.shift()] = newValue;\n}\nasync function walk_and_store_blobs(param, type = void 0, path = [], root = false, api_info = void 0) {\n  if (Array.isArray(param)) {\n    let blob_refs = [];\n    await Promise.all(\n      param.map(async (v, i) => {\n        var _a;\n        let new_path = path.slice();\n        new_path.push(i);\n        const array_refs = await walk_and_store_blobs(\n          param[i],\n          root ? ((_a = api_info == null ? void 0 : api_info.parameters[i]) == null ? void 0 : _a.component) || void 0 : type,\n          new_path,\n          false,\n          api_info\n        );\n        blob_refs = blob_refs.concat(array_refs);\n      })\n    );\n    return blob_refs;\n  } else if (globalThis.Buffer && param instanceof globalThis.Buffer) {\n    const is_image = type === \"Image\";\n    return [\n      {\n        path,\n        blob: is_image ? false : new NodeBlob([param]),\n        type\n      }\n    ];\n  } else if (typeof param === \"object\") {\n    let blob_refs = [];\n    for (let key in param) {\n      if (param.hasOwnProperty(key)) {\n        let new_path = path.slice();\n        new_path.push(key);\n        blob_refs = blob_refs.concat(\n          await walk_and_store_blobs(\n            param[key],\n            void 0,\n            new_path,\n            false,\n            api_info\n          )\n        );\n      }\n    }\n    return blob_refs;\n  }\n  return [];\n}\nfunction skip_queue(id, config) {\n  var _a, _b, _c, _d;\n  return !(((_b = (_a = config == null ? void 0 : config.dependencies) == null ? void 0 : _a[id]) == null ? void 0 : _b.queue) === null ? config.enable_queue : (_d = (_c = config == null ? void 0 : config.dependencies) == null ? void 0 : _c[id]) == null ? void 0 : _d.queue) || false;\n}\nasync function resolve_config(fetch_implementation, endpoint, token) {\n  const headers = {};\n  if (token) {\n    headers.Authorization = `Bearer ${token}`;\n  }\n  if (typeof window !== \"undefined\" && window.gradio_config && location.origin !== \"http://localhost:9876\" && !window.gradio_config.dev_mode) {\n    const path = window.gradio_config.root;\n    const config = window.gradio_config;\n    config.root = resolve_root(endpoint, config.root, false);\n    return { ...config, path };\n  } else if (endpoint) {\n    let response = await fetch_implementation(`${endpoint}/config`, {\n      headers\n    });\n    if (response.status === 200) {\n      const config = await response.json();\n      config.path = config.path ?? \"\";\n      config.root = endpoint;\n      return config;\n    }\n    throw new Error(\"Could not get config.\");\n  }\n  throw new Error(\"No config or app endpoint found\");\n}\nasync function check_space_status(id, type, status_callback) {\n  let endpoint = type === \"subdomain\" ? `https://huggingface.co/api/spaces/by-subdomain/${id}` : `https://huggingface.co/api/spaces/${id}`;\n  let response;\n  let _status;\n  try {\n    response = await fetch(endpoint);\n    _status = response.status;\n    if (_status !== 200) {\n      throw new Error();\n    }\n    response = await response.json();\n  } catch (e) {\n    status_callback({\n      status: \"error\",\n      load_status: \"error\",\n      message: \"Could not get space status\",\n      detail: \"NOT_FOUND\"\n    });\n    return;\n  }\n  if (!response || _status !== 200)\n    return;\n  const {\n    runtime: { stage },\n    id: space_name\n  } = response;\n  switch (stage) {\n    case \"STOPPED\":\n    case \"SLEEPING\":\n      status_callback({\n        status: \"sleeping\",\n        load_status: \"pending\",\n        message: \"Space is asleep. Waking it up...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"PAUSED\":\n      status_callback({\n        status: \"paused\",\n        load_status: \"error\",\n        message: \"This space has been paused by the author. If you would like to try this demo, consider duplicating the space.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n    case \"RUNNING\":\n    case \"RUNNING_BUILDING\":\n      status_callback({\n        status: \"running\",\n        load_status: \"complete\",\n        message: \"\",\n        detail: stage\n      });\n      break;\n    case \"BUILDING\":\n      status_callback({\n        status: \"building\",\n        load_status: \"pending\",\n        message: \"Space is building...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    default:\n      status_callback({\n        status: \"space_error\",\n        load_status: \"error\",\n        message: \"This space is experiencing an issue.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n  }\n}\nfunction handle_message(data, last_status) {\n  const queue = true;\n  switch (data.msg) {\n    case \"send_data\":\n      return { type: \"data\" };\n    case \"send_hash\":\n      return { type: \"hash\" };\n    case \"queue_full\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          message: QUEUE_FULL_MSG,\n          stage: \"error\",\n          code: data.code,\n          success: data.success\n        }\n      };\n    case \"heartbeat\":\n      return {\n        type: \"heartbeat\"\n      };\n    case \"unexpected_error\":\n      return {\n        type: \"unexpected_error\",\n        status: {\n          queue,\n          message: data.message,\n          stage: \"error\",\n          success: false\n        }\n      };\n    case \"estimation\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: last_status || \"pending\",\n          code: data.code,\n          size: data.queue_size,\n          position: data.rank,\n          eta: data.rank_eta,\n          success: data.success\n        }\n      };\n    case \"progress\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          progress_data: data.progress_data,\n          success: data.success\n        }\n      };\n    case \"log\":\n      return { type: \"log\", data };\n    case \"process_generating\":\n      return {\n        type: \"generating\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : null,\n          stage: data.success ? \"generating\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          eta: data.average_duration\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_completed\":\n      if (\"error\" in data.output) {\n        return {\n          type: \"update\",\n          status: {\n            queue,\n            message: data.output.error,\n            stage: \"error\",\n            code: data.code,\n            success: data.success\n          }\n        };\n      }\n      return {\n        type: \"complete\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : void 0,\n          stage: data.success ? \"complete\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_starts\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          size: data.rank,\n          position: 0,\n          success: data.success,\n          eta: data.eta\n        }\n      };\n  }\n  return { type: \"none\", status: { stage: \"error\", queue } };\n}\nexport {\n  FileData,\n  api_factory,\n  client,\n  duplicate,\n  post_data,\n  prepare_files,\n  upload,\n  upload_files\n};\n"],"names":["$9b72dfb568173b1a$var$NodeBlob","$b63be9b0371e788c$var$file","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$export$f7ad0328861e2f03","$18c11f3350a906ea$var$mapping","Map","baseUrl","manifest","i","length","path","resolved","URL","toString","$Gr8vk","Promise","all","then","resolve","url","JSON","parse","$9b72dfb568173b1a$var$fn","Intl","Collator","numeric","compare","$9b72dfb568173b1a$var$semiver","a","b","bool","split","slice","join","test","$9b72dfb568173b1a$var$resolve_root","base_url","root_path","prioritize_base","startsWith","$9b72dfb568173b1a$var$determine_protocol","endpoint","protocol","host","endsWith","ws_protocol","http_protocol","$9b72dfb568173b1a$var$RE_SPACE_NAME","$9b72dfb568173b1a$var$RE_SPACE_DOMAIN","$9b72dfb568173b1a$var$process_endpoint","app_reference","token","headers","Authorization","_app_reference","trim","res","fetch","status","_host","json","space_id","message","replace","$9b72dfb568173b1a$var$RE_DISABLED_DISCUSSION","$9b72dfb568173b1a$var$discussions_enabled","error","r","method","$9b72dfb568173b1a$export$aa5a39f77f24e0c0","constructor","orig_name","size","blob","is_stream","mime_type","alt_text","meta","_type","$9b72dfb568173b1a$var$QUEUE_FULL_MSG","$9b72dfb568173b1a$var$BROKEN_CONNECTION_MSG","post_data","$9b72dfb568173b1a$export$95aa8a13ede09e64","upload_files","$9b72dfb568173b1a$export$db33103a2a87725a","client","$9b72dfb568173b1a$export$388e0302ca0d9a41","handle_blob","$9b72dfb568173b1a$var$handle_blob","$9b72dfb568173b1a$export$e70d99f56c8376bd","fetch_implementation","EventSource_factory","post_data2","upload_files2","client2","handle_blob2","body","output","response","stringify","root","files","upload_id","uploadResponses","chunk","formData","FormData","forEach","file","append","upload_url","push","options","config","api","status_callback","hf_token","return_obj","predict","data","event_data","dependency","data_returned","status_complete","dependencies","trimmed_endpoint","api_map","types","continuous","res2","rej","result","app","submit","on","d","destroy","stage","view_api","component_server","window","Websocket","ws","Blob","WebSocket","session_hash","Math","random","substring","last_status","stream_open","pending_stream_messages","pending_diff_streams","event_stream","event_callbacks","unclosed_events","Set","jwt","config_success","_config","fns","apis","location","api_name","auth_required","console","handle_space_sucess","$9b72dfb568173b1a$var$resolve_config","load_status","detail","$9b72dfb568173b1a$var$get_jwt","$9b72dfb568173b1a$var$check_space_status","trigger_id","fn_index","api_info","websocket","eventSource","payload","unnamed_endpoints","named_endpoints","_endpoint","event_id","complete","listener_map","url_params","fire_event","event","listeners","narrowed_listener_map","type","l","eventType","listener","off","cancel","filter","_status","queue","time","Date","cancel_request","readyState","addEventListener","close","warn","event_type","fn2","URLSearchParams","search","_payload","_b","_a","enable_queue","_d","_c","searchParams","onclose","evt","wasClean","broken","onmessage","data2","$9b72dfb568173b1a$var$handle_message","send","log","level","version","hash","params","_data","_","status2","callback","event_id2","value","obj","new_data","diff","action","$9b72dfb568173b1a$var$apply_edit","target","current","last_path","Array","isArray","splice","Number","close_stream","msg","add","delete","setTimeout","keys","map","onerror","status_code","eta","average_duration","catch","component_id","fn_name","root_url","component","components","find","comp","props","ok","statusText","config2","serialize","$9b72dfb568173b1a$var$transform_api_info","key","cat","dep_index","info","parameters","returns","label","serializer","$9b72dfb568173b1a$var$get_type","description","$9b72dfb568173b1a$var$get_description","blob_refs","$9b72dfb568173b1a$var$walk_and_store_blobs","file_url","name","$9b72dfb568173b1a$var$update_object","args","EventSource","signature_type","space","object","newValue","stack","shift","param","new_path","array_refs","concat","Buffer","is_image","hasOwnProperty","gradio_config","origin","dev_mode","runtime","space_name","discussions_enabled","success","queue_size","position","rank","rank_eta","progress_data","$b63be9b0371e788c$var$submit","document","getElementById","$b63be9b0371e788c$var$drag_over","$b63be9b0371e788c$var$upload_input","$b63be9b0371e788c$var$image_zone","$b63be9b0371e788c$var$upload_image","$b63be9b0371e788c$var$upload_title","$b63be9b0371e788c$var$makePrediction","$b63be9b0371e788c$var$addImage","fl","bgUrl","createObjectURL","classList","style","backgroundImage","$b63be9b0371e788c$var$removeImage","remove","reader","FileReader","onload","readAsText","preventDefault","dataTransfer","items","item","kind","getAsFile","input","click"],"version":3,"file":"index.f2ad3f5c.js.map"}